{"version":3,"mappings":"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GACA,kBACA,6CACAE,GACA,8DACA,SACA,gBACA,MACA,QACA,kBACA,EACA,uDACAA,CACA,EACAC,KACAC,GACA,QACA,OACA,EACAN,YACAtV,uBACA6V,UACAA,mBACA,WACA,EACAC,MACAL,2BACAE,UACAL,qBACAzJ,2BACA,2BACA,EACA,EACA,sCACA,mBACA,mBACA,SACA,eACA,oBACAkK,uBACAJ,UACA,QACA,CACA,6CACAE,sDACAG,QACAL,UACA,QACA,CAKA,GAJAE,2BACA,kBACAA,uHAEAA,OACAA,UACAG,MACAF,KACA,QACA,CACAD,6BACAG,MACAJ,sEACA,CACA,oCACA,cAEA,6CACA,gCACA,mBACA,SACA,aACA,MACA,4EACA,GACAK,2DACA,WACA,aACAJ,QACAG,MACAF,KACA,WACA,CACA,CACAI,cACA,WAEA,2BACA,gBACAH,0BACA,MACA,eACAA,6CACA,MACA,WACA,QACAA,0BACA,KACA,CACAD,KACA,GACA,GACA,iBACA,0CACA,gCACA,CACA,YACA,0BACA,aACAK,eACAC,OACA,CACA,yCACA,2CACA,CAEA,UACA,eACA,0BACA,kCACA,YACA,gBACA,EAEAC,IACA,QACA,gBACA,OACA,YACA,YACA,OACA,OACA,QACA,SACA,UACA,EACAC,wDAEA,uBACA,yBACA,yCACAC,0CACAA,IAEAA,yBACA,iDACA,wBACAA,sBACA,kBAEA,GACA,2DACAA,gBACA,iBACA,GACA,gEACAA,sEAEA,+BACAA,uCACAA,gDACAA,4BACA,kCACA,yBACAC,+CACAA,CACA,GAEAD,EACA,CACA,qBACA,8BACAnI,yBACAA,iBAEA,sBACAA,QACA,wBACA,YAGA,QACA,CAEA,aACA,kCACA,qBACA,sBACA,eACA,SACA,WACA,SACA,UACA,SACA,CACA,cACA,WACA,SACA,YACA,SACA,WACA,uBACA,GACAmI,kDACA,EACA,GACA,QACA,SACA,CACA,EACAE,UACAC,YAGAC,4DACA,iBACA,uBACA,kBACA,SACA,mCACA,kBACA,aACA,gBACA,eACAtB,YACA5N,uCACA,iBACA,oBACA,qBACA,gBACA,GACA,gBACA,CAEA,QACA,CAEA,gBACAmP,QACAC,QACA,qBACAD,KACAA,6BAEA,eACA,8CACA,wCACA,mBACA,WACAE,cACAA,aACA,EACAC,SACAD,+BAEA,WAEA,iBACA,WACAA,aACA,EACAC,WACAD,gBACAA,iBACAE,KAEA,CACA,eACA,YAEAF,iBACA,CAEA,aACA3W,QACA,2CACA,OACA,OACA,kCACA8W,cACAV,aACAA,iBACA,kBAEA,GACA,wCACAW,IACAX,OACA,EACA,2BACA,WACAY,mBACA,iBACA,aACA,MACA,4CAGA,GAFA,iDACAC,WACAA,aACA,gBACA,8BACAb,mBACAvW,mCACAqX,WACAd,mCAEA,GACAe,YACA,KACA,UACA,EACA,MACA,oBACAC,uBAEA,oCACA,kEACA,YACA,MACA,CACA,CACAD,MACA,GACAH,uBACA,CACA,CACA,CACA,EAEAK,QACA,CACA,OACA,mBACA,wEACA,uBACA,kDACA,SACA,kEACA,iCACA,gCACA,oCACA3T,OACA,eACA0S,SACA,CAEA,CACAY,sCACA,CACA,CACA,GAGAM,QACA,CACA,OACA,mBACAN,iBACA,CACA,CACA,GAGAO,QACA,CACA,OACA,kCACA,0BACAnB,0BACA,oBAEA,CACA,CACA,GAKAoB,QACA,CACA,OACA,4BACA,uBACAC,8BACA,8BAEArB,kDACA,mEAEAsB,sBACAtB,iCAEA,EACA,mBACAY,sBACA,wBACA,EACA,CACA,CACA,CACA,GAGAW,OACA,CACA,OACA,8BACA,yCACA,OACA,+BACA,uCACAC,yBACA,kFACAC,sEACA,EACA,CACA,CACA,GAGAC,QACA,gBACA,WACAC,KACA,0CACAlY,yCACAkY,OAEA9J,MACA,GACA,MACA,kFACA+J,QACA,cAEA,sCACA,EACA,OACA,OACA,yBACAhB,sBACAZ,yBACAA,EACA,CACA,EACA,kCACA,2DACA,yBAEAY,cACAA,uBACAA,oBACA,EACA,4BACA,cACA,6BACA,OACA,sBACA,uDACA,qCACAiB,2BACAC,gBAEA,GADA,6BACA9C,kBACA,OACA,UACAA,qBACA+C,wBACAnB,UACAA,qBACAmB,2BACA/C,oBACA,EAEA,GACA4B,mBACA5B,uCAEA,CACA,CACA,CACA,EAEA,eACA,6BACA,CACA,UACA,OACA,OACA,OACA,QACA,SACA,UACA,EAEA,OACA,iBACAgD,UAEAC,MAEA,qBACA,WACA,gHACA,cACAC,mCACA,IACA,yCACAC,UACAA,kBACAA,EACA,CACA,CAEA,cACAC,KACAnB,KACAC,KACAE,KACAM,KACAP,IACA,EACAkB,YACAd,4EACA,EACA,kBACA,YACA,KACA,oDACA,GACA,aACArC,CACA,CACA,kBACA,SACAoD,KACAC,IACA,aACA3Y,kBACAmH,oBACAnH,WACA,QACA,iCACA,EACAA,mDACA,4CACAsV,GACA,kBACA,cACA,QACA,EACA,YACA,QACA,EACA,UACA,SACA,OACA,QACA,OACA,EACA,yBACAsD,4BACAC,UACAC,IACA,CACA,UACAD,cACAE,YACA,IACAL,uBACAK,UACAD,IACA,GACA,CACA,EACA,SACAD,YACAE,cACAH,kBACAE,KAEAC,EACA,CACA,CACA,CACA,EACA,oBACA,iCACA,sCACA,yBACA,4BACA,wBACA,oCACAC,kBACA,CAEA,0CACAA,MACA,EACA,UACA,sBACA,eACA,YACAC,CACA,CACA,EACA,kCACA3D,CACA,CAiCA,eACA,qCACA,CACA,oBACA,wBACA,SACA,cACA,UACA,SACA,oBACA,yBACA,uBACA,SACA,2BACA,+BACAxT,wCACA,YACA,+BACAoX,MACA,YACA,CACA,EACA,mCACAC,eACAA,CACA,CACA,QACA,CAKA,4BAGAC,aACA,cACA,yBACA,CACA,kBACA,YACA,KACA,6CACA,SACAC,KACA,iCACA,CACA,GACAC,GACA,WACAC,KACAhJ,oCACAA,gBAEA,CACA,EACA,2BACA+E,CACA,CAeA,cACA,CACA,OACA,8BACA,yBACAoC,2BACA,CACA,CACA,GAmKA,oBACA,aAEA,IADAtM,KAEA,mBACA,eACAoO,QACAC,aACA,GACA,0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","names":["suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","key","value","destr","options","_lval","error","HASH_RE","AMPERSAND_RE","EQUAL_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","encode","text","encodeQueryValue","encodeQueryKey","decode","decodeQueryValue","parseQuery","parametersString","object","parameter","s","encodeQueryItem","_value","stringifyQuery","query","k","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","hasProtocol","inputString","acceptProtocolRelative","TRAILING_SLASH_RE","hasTrailingSlash","input","queryParameters","withoutTrailingSlash","s0","withTrailingSlash","hasLeadingSlash","withoutLeadingSlash","withLeadingSlash","withBase","base","isEmptyURL","_base","joinURL","withQuery","parsed","parseURL","mergedQuery","stringifyParsedURL","url","isNonEmptyURL","index","url2","isEqual","a","b","defaultProto","parsePath","protocol","auth","hostAndPath","host","path","pathname","search","hash","fullpath","FetchError","createFetchError","request","response","message","fetchError","payloadMethods","isPayloadMethod","method","isJSONSerializable","textTypes","JSON_RE","detectResponseType","_contentType","contentType","retryStatusCodes","createFetch","globalOptions","onError","context","isAbort","retries","responseCode","$fetchRaw","_request","_options","Headers","fetch","responseType","data","parseFunction","$fetch","r","defaultOptions","_globalThis","ofetch","appConfig","useRuntimeConfig","baseURL","flatHooks","configHooks","hooks","parentName","subHook","name","serialCaller","arguments_","promise","hookFunction","parallelCaller","hook","callEachWith","callbacks","argument0","callback","Hookable","function_","originalName","dep","_unreg","_function","deprecated","_hooks","deprecatedHooks","removeFns","unreg","caller","event","result","createHooks","createContext","currentInstance","isSingleton","checkConflict","instance","replace","onRestore","onLeave","asyncHandlers","createNamespace","contexts","globalKey","defaultNamespace","getContext","asyncHandlersKey","executeAsync","restores","leaveHandler","restore2","restore","awaitable","nuxtAppCtx","NuxtPluginIndicator","normalizePlugins","_plugins","plugin","nuxtApp","defineNuxtPlugin","callWithNuxt","nuxt","setup","args","fn","useNuxtApp","nuxtAppInstance","vm","getCurrentInstance","H3Error","obj","createError","isError","err","_a","MIMES","defer","send","type","defaultContentType","resolve","sendRedirect","location","code","html","appendResponseHeader","current","appendHeader","useError","toRef","showError","_err","_createError","useState","autoKey","_key","init","state","initialValue","isRef","useRouter","useRoute","inject","defineNuxtRouteMiddleware","middleware","navigateTo","to","toPath","isExternal","router","redirectLocation","firstNonUndefined","DEFAULT_EXTERNAL_REL_ATTRIBUTE","props","prefetched","el","resolveComponent","slots","target","rel","navigate","h","isObject","_defu","baseObject","defaults","namespace","merger","createDefu","p","c","defu","defuFn","currentValue","_namespace","inlineConfig","isVue2","activePinia","setActivePinia","pinia","piniaSymbol","isPlainObject","o","MutationType","createPinia","scope","effectScope","ref","_p","toBeInstalled","markRaw","app","noop","addSubscription","subscriptions","detached","onCleanup","removeSubscription","idx","getCurrentScope","onScopeDispose","triggerSubscriptions","mergeReactiveObjects","patchToApply","subPatch","targetValue","isReactive","skipHydrateSymbol","shouldHydrate","isComputed","createOptionsStore","id","hot","initialState","store","localState","toRefs","assign","actions","getters","computedGetters","computed","createSetupStore","newState","$state","$id","isOptionsStore","optionsForPlugin","$subscribeOptions","isListening","isSyncListening","actionSubscriptions","debuggerEvents","activeListener","$patch","partialStateOrMutator","subscriptionMutation","myListenerId","nextTick","$reset","$dispose","wrapAction","action","afterCallbackList","onErrorCallbackList","after","ret","partialStore","stopWatcher","watch","reactive","setupStore","prop","actionValue","toRaw","extender","defineStore","idOrOptions","setupOptions","isSetupStore","useStore","components","_nuxt_components_plugin_mjs_KR1HBZs4kY","TagsWithInnerContent","HasElementTags$1","UniqueTags$1","tagName","markSideEffect","$el","staleSideEffects","head","renderCtx","renders","pendingRenders","ctx2","markEl","dom","setAttrs","matchIdx","queue","domUpdatePromise","renderDOMHead","ValidHeadTags","TagConfigKeys","tag","newTag","sortTags","tagWeight","UniqueTags","template","title","tags","newTitle","titleTemplateIdx","dedupeKeys","dedupe","ctx","strategy","oldProps","deduping","dedupeKey","SortTagsPlugin","TitleTemplatePlugin","DeprecatedTagAttrPlugin","ProvideTagHashPlugin","isDynamic","entry","PatchDomOnEntryUpdatesPlugin","delayFn","debouncedRenderDOMHead","EventHandlersPlugin","eventHandlers","delayedSrc","eventName","eventDedupeKey","$eventListenerTarget","getActiveHead","TagEntityBits","tagPromises","t","DedupesTagsPlugin","DOMPlugins","_sde","_eid","activeEntry","entries","updated","e","resolveCtx","sde","dynamic","unrefdObj","headSymbol","VueReactiveUseHeadPlugin","vuePlugin","Vue3","watchEffect","resolvedInput","injectHead","HasElementTags","tagDedupeKey","n","val","attrSdeKey","classSdeKey","hashCode","i","preRenderTag","_b","pos","elTag","doDomUpdate","legacyHead","api","force","unhead","initHeadObject","version","appHead","appLayoutTransition","appPageTransition","appKeepalive","node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0","createHead","useHead","__vitePreload","meta","renderSSRHead","_routes","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta","m","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta","C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta","routerOptions0","from","savedPosition","position","_isDifferentRoute","_getHashElementScrollMarginTop","hasTransition","route","defaultPageTransition","hookToWait","selector","elem","samePageComponent","configRouterOptions","routerOptions","validate","globalMiddleware","namedMiddleware","node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB","routerBase","routes","initialURL","previousRoute","syncCurrentRoute","_route","middlewareEntries","node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq","interpolatePath","match","generateRouteKey","override","routeProps","matchedRoute","source","wrapInKeepAlive","children","Fragment","defineComponent","_props","_wrapIf","component","done","transitionProps","Transition","_d","layouts","LayoutLoader","layout"],"sources":["../../../node_modules/destr/dist/index.mjs","../../../node_modules/ufo/dist/index.mjs","../../../node_modules/ofetch/dist/shared/ofetch.5cb01515.mjs","../../../node_modules/ofetch/dist/index.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/paths.mjs","../../../node_modules/hookable/dist/index.mjs","../../../node_modules/unctx/dist/index.mjs","../../../node_modules/nuxt/dist/app/nuxt.mjs","../../../node_modules/h3/dist/index.mjs","../../../node_modules/nuxt/dist/app/composables/error.mjs","../../../node_modules/nuxt/dist/app/composables/state.mjs","../../../node_modules/nuxt/dist/app/composables/router.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-link.mjs","../../../node_modules/defu/dist/defu.mjs","../../app.config.mjs","../../../node_modules/nuxt/dist/app/compat/vue-demi.mjs","../../../node_modules/pinia/dist/pinia.mjs","../../../node_modules/@pinia/nuxt/dist/runtime/plugin.vue3.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/components.plugin.mjs","../../../node_modules/@unhead/vue/dist/index.mjs","../../../node_modules/@unhead/dom/dist/index.mjs","../../../node_modules/@vueuse/head/dist/index.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/nuxt.config.mjs","../../../node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/routes.mjs","../../../node_modules/nuxt/dist/pages/runtime/router.options.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/router.options.mjs","../../../node_modules/nuxt/dist/pages/runtime/validate.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/middleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/router.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/plugins/server.mjs","../../../node_modules/nuxt/dist/pages/runtime/utils.mjs","../../../node_modules/nuxt/dist/app/components/utils.mjs","../../../node_modules/nuxt/dist/pages/runtime/page.mjs","../../../virtual:nuxt:C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/layouts.mjs","../../../node_modules/nuxt/dist/app/components/layout.mjs","../../../node_modules/nuxt/dist/app/entry.mjs"],"sourcesContent":["const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^[\"[{]|^-?\\d[\\d.]{0,14}$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\") {\n    return;\n  }\n  return value;\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _lval = value.toLowerCase();\n  if (_lval === \"true\") {\n    return true;\n  }\n  if (_lval === \"false\") {\n    return false;\n  }\n  if (_lval === \"null\") {\n    return null;\n  }\n  if (_lval === \"nan\") {\n    return Number.NaN;\n  }\n  if (_lval === \"infinity\") {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (_lval === \"undefined\") {\n    return void 0;\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\n\nexport { destr as default };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5b/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5d/gi;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key]) {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nconst PROTOCOL_REGEX = /^\\w+:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputString, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputString) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputString);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(index) : index;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url.append(createURL(index));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^/:]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^#/?]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path.replace(/\\/(?=[A-Za-z]:)/, \"\"));\n  return {\n    protocol,\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, joinURL, normalizeURL, parseAuth, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"FetchError\";\n  }\n}\nfunction createFetchError(request, error, response) {\n  let message = \"\";\n  if (request && response) {\n    message = `${response.status} ${response.statusText} (${request.toString()})`;\n  }\n  if (error) {\n    message = `${error.message} (${message})`;\n  }\n  const fetchError = new FetchError(message);\n  Object.defineProperty(fetchError, \"request\", { get() {\n    return request;\n  } });\n  Object.defineProperty(fetchError, \"response\", { get() {\n    return response;\n  } });\n  Object.defineProperty(fetchError, \"data\", { get() {\n    return response && response._data;\n  } });\n  Object.defineProperty(fetchError, \"status\", { get() {\n    return response && response.status;\n  } });\n  Object.defineProperty(fetchError, \"statusText\", { get() {\n    return response && response.statusText;\n  } });\n  Object.defineProperty(fetchError, \"statusCode\", { get() {\n    return response && response.status;\n  } });\n  Object.defineProperty(fetchError, \"statusMessage\", { get() {\n    return response && response.statusText;\n  } });\n  return fetchError;\n}\n\nconst payloadMethods = new Set(Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]));\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift();\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  409,\n  425,\n  429,\n  500,\n  502,\n  503,\n  504\n]);\nfunction createFetch(globalOptions) {\n  const { fetch, Headers } = globalOptions;\n  function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" || false;\n    if (context.options.retry !== false && !isAbort) {\n      const retries = typeof context.options.retry === \"number\" ? context.options.retry : isPayloadMethod(context.options.method) ? 0 : 1;\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && retryStatusCodes.has(responseCode)) {\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(context.request, context.error, context.response);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: { ...globalOptions.defaults, ..._options },\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.onRequest) {\n      await context.options.onRequest(context);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query || context.options.params) {\n        context.request = withQuery(context.request, { ...context.options.params, ...context.options.query });\n      }\n      if (context.options.body && isPayloadMethod(context.options.method) && isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers);\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      }\n    }\n    context.response = await fetch(context.request, context.options).catch(async (error) => {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await context.options.onRequestError(context);\n      }\n      return onError(context);\n    });\n    const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n    if (responseType === \"json\") {\n      const data = await context.response.text();\n      const parseFunction = context.options.parseResponse || destr;\n      context.response._data = parseFunction(data);\n    } else if (responseType === \"stream\") {\n      context.response._data = context.response.body;\n    } else {\n      context.response._data = await context.response[responseType]();\n    }\n    if (context.options.onResponse) {\n      await context.options.onResponse(context);\n    }\n    if (context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await context.options.onResponseError(context);\n      }\n      return onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = function $fetch2(request, options) {\n    return $fetchRaw(request, options).then((r) => r._data);\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = fetch;\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ofetch.5cb01515.mjs';\nexport { F as FetchError, c as createFetch, a as createFetchError } from './shared/ofetch.5cb01515.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ofetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst ofetch = createFetch({ fetch, Headers });\nconst $fetch = ofetch;\n\nexport { $fetch, Headers, fetch, ofetch };\n","import { joinURL } from 'C:/NUXT/itlWiki_3/ITLWIKI/node_modules/ufo/dist/index.mjs'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinURL(publicBase, ...path) : publicBase\n}\nif (process.client) {\n  globalThis.__buildAssetsURL = buildAssetsURL\n  globalThis.__publicAssetsURL = publicAssetsURL\n}","function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce((promise, task) => promise.then(() => function_(task)), Promise.resolve());\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce((promise, hookFunction) => promise.then(() => hookFunction.apply(void 0, arguments_)), Promise.resolve());\n}\nfunction parallelCaller(hooks, arguments_) {\n  return Promise.all(hooks.map((hook) => hook.apply(void 0, arguments_)));\n}\nfunction callEachWith(callbacks, argument0) {\n  for (const callback of callbacks) {\n    callback(argument0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    this._hooks[name] = void 0;\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map((key) => this.hook(key, hooks[key]));\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  callHook(name, ...arguments_) {\n    return this.callHookWith(serialCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    return this.callHookWith(parallelCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(this._hooks[name] || [], arguments_);\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      const index = this._before.indexOf(function_);\n      if (index !== -1) {\n        this._before.splice(index, 1);\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      const index = this._after.indexOf(function_);\n      if (index !== -1) {\n        this._after.splice(index, 1);\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (!filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (!filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n","function createContext() {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  return {\n    use: () => {\n      if (currentInstance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return currentInstance;\n    },\n    tryUse: () => {\n      return currentInstance;\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace() {\n  const contexts = {};\n  return {\n    get(key) {\n      if (!contexts[key]) {\n        contexts[key] = createContext();\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key) => defaultNamespace.get(key);\nconst useContext = (key) => getContext(key).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\"[unctx] `withAsyncContext` needs transformation for async context support in\", function_, \"\\n\", function_.toString());\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { getCurrentInstance, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = getContext(\"nuxt-app\");\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    provide: void 0,\n    globalName: \"nuxt\",\n    payload: reactive({\n      data: {},\n      state: {},\n      _errors: {},\n      ...process.client ? window.__NUXT__ : { serverRendered: true }\n    }),\n    static: {\n      data: {}\n    },\n    isHydrating: process.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (process.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.payload.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  const runtimeConfig = process.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  const compatibilityConfig = new Proxy(runtimeConfig, {\n    get(target, prop) {\n      if (prop === \"public\") {\n        return target.public;\n      }\n      return target[prop] ?? target.public[prop];\n    },\n    set(target, prop, value) {\n      if (process.server || prop === \"public\" || prop === \"app\") {\n        return false;\n      }\n      target[prop] = value;\n      target.public[prop] = value;\n      return true;\n    }\n  });\n  nuxtApp.provide(\"config\", compatibilityConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin !== \"function\") {\n    return;\n  }\n  const { provide } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};\n  if (provide && typeof provide === \"object\") {\n    for (const key in provide) {\n      nuxtApp.provide(key, provide[key]);\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  for (const plugin of plugins) {\n    await applyPlugin(nuxtApp, plugin);\n  }\n}\nexport function normalizePlugins(_plugins) {\n  const unwrappedPlugins = [];\n  const legacyInjectPlugins = [];\n  const invalidPlugins = [];\n  const plugins = _plugins.map((plugin) => {\n    if (typeof plugin !== \"function\") {\n      invalidPlugins.push(plugin);\n      return null;\n    }\n    if (plugin.length > 1) {\n      legacyInjectPlugins.push(plugin);\n      return (nuxtApp) => plugin(nuxtApp, nuxtApp.provide);\n    }\n    if (!isNuxtPlugin(plugin)) {\n      unwrappedPlugins.push(plugin);\n    }\n    return plugin;\n  }).filter(Boolean);\n  if (process.dev && legacyInjectPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin with legacy Nuxt 2 format (context, inject) which is likely to be broken. In the future they will be ignored:\", legacyInjectPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  if (process.dev && invalidPlugins.length) {\n    console.warn(\"[warn] [nuxt] Some plugins are not exposing a function and skipped:\", invalidPlugins);\n  }\n  if (process.dev && unwrappedPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin that has not been wrapped in `defineNuxtPlugin`. It is advised to wrap your plugins as in the future this may enable enhancements:\", unwrappedPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  return plugins;\n}\nexport function defineNuxtPlugin(plugin) {\n  plugin[NuxtPluginIndicator] = true;\n  return plugin;\n}\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (process.server) {\n    return nuxtAppCtx.callAsync(nuxt, fn);\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return fn();\n  }\n}\nexport function useNuxtApp() {\n  const nuxtAppInstance = nuxtAppCtx.tryUse();\n  if (!nuxtAppInstance) {\n    const vm = getCurrentInstance();\n    if (!vm) {\n      throw new Error(\"nuxt instance unavailable\");\n    }\n    return vm.appContext.app.$nuxt;\n  }\n  return nuxtAppInstance;\n}\nexport function useRuntimeConfig() {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1 } from 'ufo';\nimport { createRouter as createRouter$1 } from 'radix3';\nimport destr from 'destr';\nimport { parse, serialize } from 'cookie-es';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base) {\n    return handler;\n  }\n  return eventHandler((event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    event.node.req.url = withoutBase(event.node.req.url || \"/\", base);\n    return handler(event);\n  });\n}\n\nclass H3Error extends Error {\n  constructor() {\n    super(...arguments);\n    this.statusCode = 500;\n    this.fatal = false;\n    this.unhandled = false;\n    this.statusMessage = void 0;\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: this.statusCode\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = this.statusMessage;\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\nH3Error.__h3_error__ = true;\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage, input.cause ? { cause: input.cause } : void 0);\n  if (\"stack\" in input) {\n    try {\n      Object.defineProperty(err, \"stack\", { get() {\n        return input.stack;\n      } });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = input.statusCode;\n  } else if (input.status) {\n    err.statusCode = input.status;\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  if (_code) {\n    event.node.res.statusCode = _code;\n  }\n  if (h3Error.statusMessage) {\n    event.node.res.statusMessage = h3Error.statusMessage;\n  }\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.node.req.url || \"\");\n}\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  const method = getMethod(event);\n  if (allowHead && method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (method === expected) {\n      return true;\n    }\n  } else if (expected.includes(method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  if (RawBodySymbol in event.node.req) {\n    const promise2 = Promise.resolve(event.node.req[RawBodySymbol]);\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (\"body\" in event.node.req) {\n    return Promise.resolve(event.node.req.body);\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise((resolve, reject) => {\n    const bodyData = [];\n    event.node.req.on(\"error\", (err) => {\n      reject(err);\n    }).on(\"data\", (chunk) => {\n      bodyData.push(chunk);\n    }).on(\"end\", () => {\n      resolve(Buffer.concat(bodyData));\n    });\n  });\n  return encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n}\nasync function readBody(event) {\n  if (ParsedBodySymbol in event.node.req) {\n    return event.node.req[ParsedBodySymbol];\n  }\n  const body = await readRawBody(event);\n  if (event.node.req.headers[\"content-type\"] === \"application/x-www-form-urlencoded\") {\n    const parsedForm = Object.fromEntries(new URLSearchParams(body));\n    return parsedForm;\n  }\n  const json = destr(body);\n  event.node.req[ParsedBodySymbol] = json;\n  return json;\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    event.node.res.end();\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst defer = typeof setImmediate !== \"undefined\" ? setImmediate : (fn) => fn();\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      event.node.res.end(data);\n      resolve();\n    });\n  });\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = code;\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(name, value);\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction isStream(data) {\n  return data && typeof data === \"object\" && typeof data.pipe === \"function\" && typeof data.on === \"function\";\n}\nfunction sendStream(event, data) {\n  return new Promise((resolve, reject) => {\n    data.pipe(event.node.res);\n    data.on(\"end\", () => resolve());\n    data.on(\"error\", (error) => reject(createError(error)));\n  });\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map((e) => [e[0].toLowerCase(), e[1]]);\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  event.node.res.socket.write(`${hint}\\r\n\\r\n`, \"utf8\", cb);\n}\n\nfunction parseCookies(event) {\n  return parse(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  appendHeader(event, \"Set-Cookie\", cookieStr);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  const method = getMethod(event);\n  let body;\n  if (PayloadMethods.has(method)) {\n    body = await readRawBody(event).catch(() => void 0);\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  if (opts.fetchOptions?.headers) {\n    Object.assign(headers, opts.fetchOptions.headers);\n  }\n  if (opts.headers) {\n    Object.assign(headers, opts.headers);\n  }\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      headers,\n      method,\n      body,\n      ...opts.fetchOptions\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  const _fetch = opts.fetch || globalThis.fetch;\n  if (!_fetch) {\n    throw new Error(\"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\");\n  }\n  const response = await _fetch(target, {\n    headers: opts.headers,\n    ...opts.fetchOptions\n  });\n  event.node.res.statusCode = response.status;\n  event.node.res.statusMessage = response.statusText;\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  try {\n    if (response.body) {\n      if (opts.sendStream === false) {\n        const data = new Uint8Array(await response.arrayBuffer());\n        event.node.res.end(data);\n      } else {\n        for await (const chunk of response.body) {\n          event.node.res.write(chunk);\n        }\n        event.node.res.end();\n      }\n    }\n  } catch (error) {\n    event.node.res.end();\n    throw error;\n  }\n}\n\nclass H3Headers {\n  constructor(init) {\n    if (!init) {\n      this._headers = {};\n    } else if (Array.isArray(init)) {\n      this._headers = Object.fromEntries(init.map(([key, value]) => [key.toLowerCase(), value]));\n    } else if (init && \"append\" in init) {\n      this._headers = Object.fromEntries(init.entries());\n    } else {\n      this._headers = Object.fromEntries(Object.entries(init).map(([key, value]) => [key.toLowerCase(), value]));\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  entries() {\n    throw Object.entries(this._headers)[Symbol.iterator]();\n  }\n  keys() {\n    return Object.keys(this._headers)[Symbol.iterator]();\n  }\n  values() {\n    throw Object.values(this._headers)[Symbol.iterator]();\n  }\n  append(name, value) {\n    const _name = name.toLowerCase();\n    this.set(_name, [this.get(_name), value].filter(Boolean).join(\", \"));\n  }\n  delete(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  get(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  has(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  set(name, value) {\n    this._headers[name.toLowerCase()] = String(value);\n  }\n  forEach(callbackfn) {\n    for (const [key, value] of Object.entries(this._headers)) {\n      callbackfn(value, key, this);\n    }\n  }\n}\n\nclass H3Response {\n  constructor(body = null, init = {}) {\n    this.body = null;\n    this.type = \"default\";\n    this.bodyUsed = false;\n    this.headers = new H3Headers(init.headers);\n    this.status = init.status ?? 200;\n    this.statusText = init.statusText || \"\";\n    this.redirected = !!init.status && [301, 302, 307, 308].includes(init.status);\n    this._body = body;\n    this.url = \"\";\n    this.ok = this.status < 300 && this.status > 199;\n  }\n  clone() {\n    return new H3Response(this.body, {\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText\n    });\n  }\n  arrayBuffer() {\n    return Promise.resolve(this._body);\n  }\n  blob() {\n    return Promise.resolve(this._body);\n  }\n  formData() {\n    return Promise.resolve(this._body);\n  }\n  json() {\n    return Promise.resolve(this._body);\n  }\n  text() {\n    return Promise.resolve(this._body);\n  }\n}\n\nclass H3Event {\n  constructor(req, res) {\n    this[\"__is_event__\"] = true;\n    this.context = {};\n    this.node = { req, res };\n  }\n  get path() {\n    return this.req.url;\n  }\n  get req() {\n    return this.node.req;\n  }\n  get res() {\n    return this.node.res;\n  }\n  respondWith(r) {\n    Promise.resolve(r).then((_response) => {\n      if (this.res.writableEnded) {\n        return;\n      }\n      const response = _response instanceof H3Response ? _response : new H3Response(_response);\n      for (const [key, value] of response.headers.entries()) {\n        this.res.setHeader(key, value);\n      }\n      if (response.status) {\n        this.res.statusCode = response.status;\n      }\n      if (response.statusText) {\n        this.res.statusMessage = response.statusText;\n      }\n      if (response.redirected) {\n        this.res.setHeader(\"location\", response.url);\n      }\n      if (!response._body) {\n        return this.res.end();\n      }\n      if (typeof response._body === \"string\" || \"buffer\" in response._body || \"byteLength\" in response._body) {\n        return this.res.end(response._body);\n      }\n      if (!response.headers.has(\"content-type\")) {\n        response.headers.set(\"content-type\", MIMES.json);\n      }\n      this.res.end(JSON.stringify(response._body));\n    });\n  }\n}\nfunction isEvent(input) {\n  return \"__is_event__\" in input;\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\n\nfunction defineEventHandler(handler) {\n  handler.__is_handler__ = true;\n  return handler;\n}\nconst eventHandler = defineEventHandler;\nfunction isEventHandler(input) {\n  return \"__is_handler__\" in input;\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\"Invalid lazy handler result. It should be a function:\", handler);\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(normalizeLayer({ ...arg3, route: arg1, handler: arg2 }));\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(normalizeLayer({ ...arg2, route: \"/\", handler: arg1 }));\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const reqUrl = event.node.req.url || \"/\";\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!reqUrl.startsWith(layer.route)) {\n          continue;\n        }\n        event.node.req.url = reqUrl.slice(layer.route.length) || \"/\";\n      } else {\n        event.node.req.url = reqUrl;\n      }\n      if (layer.match && !layer.match(event.node.req.url, event)) {\n        continue;\n      }\n      const val = await layer.handler(event);\n      if (event.node.res.writableEnded) {\n        return;\n      }\n      const type = typeof val;\n      if (type === \"string\") {\n        return send(event, val, MIMES.html);\n      } else if (isStream(val)) {\n        return sendStream(event, val);\n      } else if (val === null) {\n        event.node.res.statusCode = 204;\n        return send(event);\n      } else if (type === \"object\" || type === \"boolean\" || type === \"number\") {\n        if (val.buffer) {\n          return send(event, val);\n        } else if (val instanceof Error) {\n          throw createError(val);\n        } else {\n          return send(event, JSON.stringify(val, void 0, spacing), MIMES.json);\n        }\n      }\n    }\n    if (!event.node.res.writableEnded) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n      });\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"Invalid handler. It should be a function:\", handler);\n  }\n  return eventHandler((event) => {\n    return callNodeListener(handler, event.node.req, event.node.res);\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      } else {\n        if (error.unhandled || error.fatal) {\n          console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n        }\n        await sendError(event, error, !!app.options.debug);\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nconst RouterMethods = [\"connect\", \"delete\", \"get\", \"head\", \"options\", \"post\", \"put\", \"trace\", \"patch\"];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.node.req.url || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched) {\n      if (opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.node.req.method || \"get\").toLowerCase();\n    const handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      throw createError({\n        statusCode: 405,\n        name: \"Method Not Allowed\",\n        statusMessage: `Method ${method} is not allowed on this route.`\n      });\n    }\n    const params = matched.params || {};\n    event.context.params = params;\n    return handler(event);\n  });\n  return router;\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fromNodeMiddleware, getCookie, getHeader, getHeaders, getMethod, getQuery, getRequestHeader, getRequestHeaders, getResponseHeader, getResponseHeaders, getRouterParam, getRouterParams, handleCacheHeaders, isError, isEvent, isEventHandler, isMethod, isStream, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readRawBody, send, sendError, sendProxy, sendRedirect, sendStream, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, toEventHandler, toNodeListener, use, useBase, writeEarlyHints };\n","import { createError as _createError } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (_err) => {\n  const err = createError(_err);\n  try {\n    const nuxtApp = useNuxtApp();\n    nuxtApp.callHook(\"app:error\", err);\n    const error = useError();\n    error.value = error.value || err;\n  } catch {\n    throw err;\n  }\n  return err;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await nuxtApp.$router.replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (err) => !!(err && typeof err === \"object\" && \"__nuxt_error\" in err);\nexport const createError = (err) => {\n  const _err = _createError(err);\n  _err.__nuxt_error = true;\n  return _err;\n};\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = \"$s\" + _key;\n  const nuxt = useNuxtApp();\n  const state = toRef(nuxt.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxt.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\n","import { getCurrentInstance, inject, onUnmounted } from \"vue\";\nimport { sendRedirect } from \"h3\";\nimport { hasProtocol, joinURL, parseURL } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nimport { useState } from \"./state.mjs\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (getCurrentInstance()) {\n    return inject(\"_route\", useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onUnmounted(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onUnmounted(unsubscribe);\n};\nexport const defineNuxtRouteMiddleware = (middleware) => middleware;\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  if (options.global || typeof name === \"function\") {\n    nuxtApp._middleware.global.push(typeof name === \"function\" ? name : middleware);\n  } else {\n    nuxtApp._middleware.named[name] = middleware;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : to.path || \"/\";\n  const isExternal = hasProtocol(toPath, true);\n  if (isExternal && !options?.external) {\n    throw new Error(\"Navigating to external URL is not allowed by default. Use `nagivateTo (url, { external: true })`.\");\n  }\n  if (isExternal && parseURL(toPath).protocol === \"script:\") {\n    throw new Error(\"Cannot navigate to an URL with script protocol.\");\n  }\n  if (process.client && !isExternal && isProcessingMiddleware()) {\n    return to;\n  }\n  const router = useRouter();\n  if (process.server) {\n    const nuxtApp = useNuxtApp();\n    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {\n      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, router.resolve(to).fullPath || \"/\");\n      return nuxtApp.callHook(\"app:redirected\").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options?.redirectCode || 302));\n    }\n  }\n  if (isExternal) {\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (process.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (err) {\n    throw createError(err);\n  }\n  return false;\n};\nexport const setPageLayout = (layout) => {\n  if (process.server) {\n    if (process.dev && getCurrentInstance() && useState(\"_layout\").value !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    useState(\"_layout\").value = layout;\n  }\n  const nuxtApp = useNuxtApp();\n  if (process.dev && nuxtApp.isHydrating && useState(\"_layout\").value !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || process.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n","import { defineComponent, h, ref, resolveComponent, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { hasProtocol } from \"ufo\";\nimport { preloadRouteComponents } from \"../composables/preload.mjs\";\nimport { navigateTo, useRouter } from \"../composables/router.mjs\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst DEFAULT_EXTERNAL_REL_ATTRIBUTE = \"noopener noreferrer\";\nconst requestIdleCallback = process.server ? void 0 : globalThis.requestIdleCallback || ((cb) => {\n  const start = Date.now();\n  const idleDeadline = {\n    didTimeout: false,\n    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n  };\n  return setTimeout(() => {\n    cb(idleDeadline);\n  }, 1);\n});\nconst cancelIdleCallback = process.server ? null : globalThis.cancelIdleCallback || ((id) => {\n  clearTimeout(id);\n});\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  const checkPropConflicts = (props, main, sub) => {\n    if (process.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  };\n  return defineComponent({\n    name: componentName,\n    props: {\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      }\n    },\n    setup(props, { slots }) {\n      const router = useRouter();\n      const to = computed(() => {\n        checkPropConflicts(props, \"to\", \"href\");\n        return props.to || props.href || \"\";\n      });\n      const isExternal = computed(() => {\n        if (props.external) {\n          return true;\n        }\n        if (props.target && props.target !== \"_self\") {\n          return true;\n        }\n        if (typeof to.value === \"object\") {\n          return false;\n        }\n        return to.value === \"\" || hasProtocol(to.value, true);\n      });\n      const prefetched = ref(false);\n      const el = process.server ? void 0 : ref(null);\n      if (process.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        const shouldPrefetch = props.prefetch !== false && props.noPrefetch !== true && typeof to.value === \"string\" && props.target !== \"_blank\" && !isSlowConnection();\n        if (shouldPrefetch) {\n          const nuxtApp = useNuxtApp();\n          const observer = useObserver();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            idleId = requestIdleCallback(() => {\n              if (el?.value?.tagName) {\n                unobserve = observer.observe(el.value, async () => {\n                  unobserve?.();\n                  unobserve = null;\n                  await Promise.all([\n                    nuxtApp.hooks.callHook(\"link:prefetch\", to.value).catch(() => {\n                    }),\n                    !isExternal.value && preloadRouteComponents(to.value, router).catch(() => {\n                    })\n                  ]);\n                  prefetched.value = true;\n                });\n              }\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      return () => {\n        if (!isExternal.value) {\n          return h(\n            resolveComponent(\"RouterLink\"),\n            {\n              ref: process.server ? void 0 : (ref2) => {\n                el.value = ref2?.$el;\n              },\n              to: to.value,\n              ...prefetched.value && !props.custom ? { class: props.prefetchedClass || options.prefetchedClass } : {},\n              activeClass: props.activeClass || options.activeClass,\n              exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n              replace: props.replace,\n              ariaCurrentValue: props.ariaCurrentValue,\n              custom: props.custom\n            },\n            slots.default\n          );\n        }\n        const href = typeof to.value === \"object\" ? router.resolve(to.value)?.href ?? null : to.value || null;\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : \"\") || null;\n        const navigate = () => navigateTo(href, { replace: props.replace });\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href,\n            navigate,\n            route: router.resolve(href),\n            rel,\n            target,\n            isExternal: isExternal.value,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", { ref: el, href, rel, target }, slots.default?.());\n      };\n    }\n  });\n}\nexport default defineNuxtLink({ componentName: \"NuxtLink\" });\nfunction useObserver() {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    if (!observer) {\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          const callback2 = callbacks.get(entry.target);\n          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n          if (isVisible && callback2) {\n            callback2();\n          }\n        }\n      });\n    }\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer.unobserve(element);\n      if (callbacks.size === 0) {\n        observer.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nfunction isSlowConnection() {\n  if (process.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || /2g/.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\n","function isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isObject(value) && isObject(object[key])) {\n      object[key] = _defu(value, object[key], (namespace ? `${namespace}.` : \"\") + key.toString(), merger);\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {});\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue, _namespace) => {\n  if (typeof object[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue, _namespace) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","\nimport { defuFn } from 'C:/NUXT/itlWiki_3/ITLWIKI/node_modules/defu/dist/defu.mjs'\n\nconst inlineConfig = {}\n\n\n\nexport default defuFn(inlineConfig)\n","export * from \"./capi.mjs\";\nexport const Vue2 = void 0;\nexport const isVue2 = false;\nexport const isVue3 = true;\n","/*!\n  * pinia v2.0.27\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\r\n * setActivePinia must be called to handle SSR at the top of functions like\r\n * `fetch`, `setup`, `serverPrefetch` and others\r\n */\r\nlet activePinia;\r\n/**\r\n * Sets or unsets the active pinia. Used in SSR and internally when calling\r\n * actions and getters\r\n *\r\n * @param pinia - Pinia instance\r\n */\r\nconst setActivePinia = (pinia) => (activePinia = pinia);\r\n/**\r\n * Get the currently active pinia if there is any.\r\n */\r\nconst getActivePinia = () => (getCurrentInstance() && inject(piniaSymbol)) || activePinia;\r\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no) {\r\n    return (o &&\r\n        typeof o === 'object' &&\r\n        Object.prototype.toString.call(o) === '[object Object]' &&\r\n        typeof o.toJSON !== 'function');\r\n}\r\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\r\n// TODO: can we change these to numbers?\r\n/**\r\n * Possible types for SubscriptionCallback\r\n */\r\nvar MutationType;\r\n(function (MutationType) {\r\n    /**\r\n     * Direct mutation of the state:\r\n     *\r\n     * - `store.name = 'new name'`\r\n     * - `store.$state.name = 'new name'`\r\n     * - `store.list.push('new item')`\r\n     */\r\n    MutationType[\"direct\"] = \"direct\";\r\n    /**\r\n     * Mutated the state with `$patch` and an object\r\n     *\r\n     * - `store.$patch({ name: 'newName' })`\r\n     */\r\n    MutationType[\"patchObject\"] = \"patch object\";\r\n    /**\r\n     * Mutated the state with `$patch` and a function\r\n     *\r\n     * - `store.$patch(state => state.name = 'newName')`\r\n     */\r\n    MutationType[\"patchFunction\"] = \"patch function\";\r\n    // maybe reset? for $state = {} and $reset\r\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\r\n/**\r\n * Should we add the devtools plugins.\r\n * - only if dev mode or forced through the prod devtools flag\r\n * - not in test\r\n * - only if window exists (could change in the future)\r\n */\r\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\n\n/*\r\n * FileSaver.js A saveAs() FileSaver implementation.\r\n *\r\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\r\n * Morote.\r\n *\r\n * License : MIT\r\n */\r\n// The one and only way of getting global scope in all environments\r\n// https://stackoverflow.com/q/3277182/1008999\r\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\r\n    ? window\r\n    : typeof self === 'object' && self.self === self\r\n        ? self\r\n        : typeof global === 'object' && global.global === global\r\n            ? global\r\n            : typeof globalThis === 'object'\r\n                ? globalThis\r\n                : { HTMLElement: null })();\r\nfunction bom(blob, { autoBom = false } = {}) {\r\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\r\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\r\n    if (autoBom &&\r\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\r\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\r\n    }\r\n    return blob;\r\n}\r\nfunction download(url, name, opts) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url);\r\n    xhr.responseType = 'blob';\r\n    xhr.onload = function () {\r\n        saveAs(xhr.response, name, opts);\r\n    };\r\n    xhr.onerror = function () {\r\n        console.error('could not download file');\r\n    };\r\n    xhr.send();\r\n}\r\nfunction corsEnabled(url) {\r\n    const xhr = new XMLHttpRequest();\r\n    // use sync to avoid popup blocker\r\n    xhr.open('HEAD', url, false);\r\n    try {\r\n        xhr.send();\r\n    }\r\n    catch (e) { }\r\n    return xhr.status >= 200 && xhr.status <= 299;\r\n}\r\n// `a.click()` doesn't work for all browsers (#465)\r\nfunction click(node) {\r\n    try {\r\n        node.dispatchEvent(new MouseEvent('click'));\r\n    }\r\n    catch (e) {\r\n        const evt = document.createEvent('MouseEvents');\r\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n        node.dispatchEvent(evt);\r\n    }\r\n}\r\nconst _navigator = \r\n typeof navigator === 'object' ? navigator : { userAgent: '' };\r\n// Detect WebView inside a native macOS app by ruling out all browsers\r\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\r\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\r\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\r\n    /AppleWebKit/.test(_navigator.userAgent) &&\r\n    !/Safari/.test(_navigator.userAgent))();\r\nconst saveAs = !IS_CLIENT\r\n    ? () => { } // noop\r\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\r\n        typeof HTMLAnchorElement !== 'undefined' &&\r\n            'download' in HTMLAnchorElement.prototype &&\r\n            !isMacOSWebView\r\n            ? downloadSaveAs\r\n            : // Use msSaveOrOpenBlob as a second approach\r\n                'msSaveOrOpenBlob' in _navigator\r\n                    ? msSaveAs\r\n                    : // Fallback to using FileReader and a popup\r\n                        fileSaverSaveAs;\r\nfunction downloadSaveAs(blob, name = 'download', opts) {\r\n    const a = document.createElement('a');\r\n    a.download = name;\r\n    a.rel = 'noopener'; // tabnabbing\r\n    // TODO: detect chrome extensions & packaged apps\r\n    // a.target = '_blank'\r\n    if (typeof blob === 'string') {\r\n        // Support regular links\r\n        a.href = blob;\r\n        if (a.origin !== location.origin) {\r\n            if (corsEnabled(a.href)) {\r\n                download(blob, name, opts);\r\n            }\r\n            else {\r\n                a.target = '_blank';\r\n                click(a);\r\n            }\r\n        }\r\n        else {\r\n            click(a);\r\n        }\r\n    }\r\n    else {\r\n        // Support blobs\r\n        a.href = URL.createObjectURL(blob);\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(a.href);\r\n        }, 4e4); // 40s\r\n        setTimeout(function () {\r\n            click(a);\r\n        }, 0);\r\n    }\r\n}\r\nfunction msSaveAs(blob, name = 'download', opts) {\r\n    if (typeof blob === 'string') {\r\n        if (corsEnabled(blob)) {\r\n            download(blob, name, opts);\r\n        }\r\n        else {\r\n            const a = document.createElement('a');\r\n            a.href = blob;\r\n            a.target = '_blank';\r\n            setTimeout(function () {\r\n                click(a);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        // @ts-ignore: works on windows\r\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\r\n    }\r\n}\r\nfunction fileSaverSaveAs(blob, name, opts, popup) {\r\n    // Open a popup immediately do go around popup blocker\r\n    // Mostly only available on user interaction and the fileReader is async so...\r\n    popup = popup || open('', '_blank');\r\n    if (popup) {\r\n        popup.document.title = popup.document.body.innerText = 'downloading...';\r\n    }\r\n    if (typeof blob === 'string')\r\n        return download(blob, name, opts);\r\n    const force = blob.type === 'application/octet-stream';\r\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\r\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\r\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\r\n        typeof FileReader !== 'undefined') {\r\n        // Safari doesn't allow downloading of blob URLs\r\n        const reader = new FileReader();\r\n        reader.onloadend = function () {\r\n            let url = reader.result;\r\n            if (typeof url !== 'string') {\r\n                popup = null;\r\n                throw new Error('Wrong reader.result type');\r\n            }\r\n            url = isChromeIOS\r\n                ? url\r\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n            if (popup) {\r\n                popup.location.href = url;\r\n            }\r\n            else {\r\n                location.assign(url);\r\n            }\r\n            popup = null; // reverse-tabnabbing #460\r\n        };\r\n        reader.readAsDataURL(blob);\r\n    }\r\n    else {\r\n        const url = URL.createObjectURL(blob);\r\n        if (popup)\r\n            popup.location.assign(url);\r\n        else\r\n            location.href = url;\r\n        popup = null; // reverse-tabnabbing #460\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(url);\r\n        }, 4e4); // 40s\r\n    }\r\n}\n\n/**\r\n * Shows a toast or console.log\r\n *\r\n * @param message - message to log\r\n * @param type - different color of the tooltip\r\n */\r\nfunction toastMessage(message, type) {\r\n    const piniaMessage = '🍍 ' + message;\r\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\r\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\r\n    }\r\n    else if (type === 'error') {\r\n        console.error(piniaMessage);\r\n    }\r\n    else if (type === 'warn') {\r\n        console.warn(piniaMessage);\r\n    }\r\n    else {\r\n        console.log(piniaMessage);\r\n    }\r\n}\r\nfunction isPinia(o) {\r\n    return '_a' in o && 'install' in o;\r\n}\n\nfunction checkClipboardAccess() {\r\n    if (!('clipboard' in navigator)) {\r\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\r\n        return true;\r\n    }\r\n}\r\nfunction checkNotFocusedError(error) {\r\n    if (error instanceof Error &&\r\n        error.message.toLowerCase().includes('document is not focused')) {\r\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nasync function actionGlobalCopyState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\r\n        toastMessage('Global state copied to clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalPasteState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        pinia.state.value = JSON.parse(await navigator.clipboard.readText());\r\n        toastMessage('Global state pasted from clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalSaveState(pinia) {\r\n    try {\r\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\r\n            type: 'text/plain;charset=utf-8',\r\n        }), 'pinia-state.json');\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nlet fileInput;\r\nfunction getFileOpener() {\r\n    if (!fileInput) {\r\n        fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.accept = '.json';\r\n    }\r\n    function openFile() {\r\n        return new Promise((resolve, reject) => {\r\n            fileInput.onchange = async () => {\r\n                const files = fileInput.files;\r\n                if (!files)\r\n                    return resolve(null);\r\n                const file = files.item(0);\r\n                if (!file)\r\n                    return resolve(null);\r\n                return resolve({ text: await file.text(), file });\r\n            };\r\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\r\n            fileInput.oncancel = () => resolve(null);\r\n            fileInput.onerror = reject;\r\n            fileInput.click();\r\n        });\r\n    }\r\n    return openFile;\r\n}\r\nasync function actionGlobalOpenStateFile(pinia) {\r\n    try {\r\n        const open = await getFileOpener();\r\n        const result = await open();\r\n        if (!result)\r\n            return;\r\n        const { text, file } = result;\r\n        pinia.state.value = JSON.parse(text);\r\n        toastMessage(`Global state imported from \"${file.name}\".`);\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\n\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\r\nconst PINIA_ROOT_ID = '_root';\r\nfunction formatStoreForInspectorTree(store) {\r\n    return isPinia(store)\r\n        ? {\r\n            id: PINIA_ROOT_ID,\r\n            label: PINIA_ROOT_LABEL,\r\n        }\r\n        : {\r\n            id: store.$id,\r\n            label: store.$id,\r\n        };\r\n}\r\nfunction formatStoreForInspectorState(store) {\r\n    if (isPinia(store)) {\r\n        const storeNames = Array.from(store._s.keys());\r\n        const storeMap = store._s;\r\n        const state = {\r\n            state: storeNames.map((storeId) => ({\r\n                editable: true,\r\n                key: storeId,\r\n                value: store.state.value[storeId],\r\n            })),\r\n            getters: storeNames\r\n                .filter((id) => storeMap.get(id)._getters)\r\n                .map((id) => {\r\n                const store = storeMap.get(id);\r\n                return {\r\n                    editable: false,\r\n                    key: id,\r\n                    value: store._getters.reduce((getters, key) => {\r\n                        getters[key] = store[key];\r\n                        return getters;\r\n                    }, {}),\r\n                };\r\n            }),\r\n        };\r\n        return state;\r\n    }\r\n    const state = {\r\n        state: Object.keys(store.$state).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store.$state[key],\r\n        })),\r\n    };\r\n    // avoid adding empty getters\r\n    if (store._getters && store._getters.length) {\r\n        state.getters = store._getters.map((getterName) => ({\r\n            editable: false,\r\n            key: getterName,\r\n            value: store[getterName],\r\n        }));\r\n    }\r\n    if (store._customProperties.size) {\r\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store[key],\r\n        }));\r\n    }\r\n    return state;\r\n}\r\nfunction formatEventData(events) {\r\n    if (!events)\r\n        return {};\r\n    if (Array.isArray(events)) {\r\n        // TODO: handle add and delete for arrays and objects\r\n        return events.reduce((data, event) => {\r\n            data.keys.push(event.key);\r\n            data.operations.push(event.type);\r\n            data.oldValue[event.key] = event.oldValue;\r\n            data.newValue[event.key] = event.newValue;\r\n            return data;\r\n        }, {\r\n            oldValue: {},\r\n            keys: [],\r\n            operations: [],\r\n            newValue: {},\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            operation: formatDisplay(events.type),\r\n            key: formatDisplay(events.key),\r\n            oldValue: events.oldValue,\r\n            newValue: events.newValue,\r\n        };\r\n    }\r\n}\r\nfunction formatMutationType(type) {\r\n    switch (type) {\r\n        case MutationType.direct:\r\n            return 'mutation';\r\n        case MutationType.patchFunction:\r\n            return '$patch';\r\n        case MutationType.patchObject:\r\n            return '$patch';\r\n        default:\r\n            return 'unknown';\r\n    }\r\n}\n\n// timeline can be paused when directly changing the state\r\nlet isTimelineActive = true;\r\nconst componentStateTypes = [];\r\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\r\nconst INSPECTOR_ID = 'pinia';\r\n/**\r\n * Gets the displayed name of a store in devtools\r\n *\r\n * @param id - id of the store\r\n * @returns a formatted string\r\n */\r\nconst getStoreType = (id) => '🍍 ' + id;\r\n/**\r\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\r\n * as soon as it is added to the application.\r\n *\r\n * @param app - Vue application\r\n * @param pinia - pinia instance\r\n */\r\nfunction registerPiniaDevtools(app, pinia) {\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia 🍍',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n    }, (api) => {\r\n        if (typeof api.now !== 'function') {\r\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\r\n        }\r\n        api.addTimelineLayer({\r\n            id: MUTATIONS_LAYER_ID,\r\n            label: `Pinia 🍍`,\r\n            color: 0xe5df88,\r\n        });\r\n        api.addInspector({\r\n            id: INSPECTOR_ID,\r\n            label: 'Pinia 🍍',\r\n            icon: 'storage',\r\n            treeFilterPlaceholder: 'Search stores',\r\n            actions: [\r\n                {\r\n                    icon: 'content_copy',\r\n                    action: () => {\r\n                        actionGlobalCopyState(pinia);\r\n                    },\r\n                    tooltip: 'Serialize and copy the state',\r\n                },\r\n                {\r\n                    icon: 'content_paste',\r\n                    action: async () => {\r\n                        await actionGlobalPasteState(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Replace the state with the content of your clipboard',\r\n                },\r\n                {\r\n                    icon: 'save',\r\n                    action: () => {\r\n                        actionGlobalSaveState(pinia);\r\n                    },\r\n                    tooltip: 'Save the state as a JSON file',\r\n                },\r\n                {\r\n                    icon: 'folder_open',\r\n                    action: async () => {\r\n                        await actionGlobalOpenStateFile(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Import the state from a JSON file',\r\n                },\r\n            ],\r\n            nodeActions: [\r\n                {\r\n                    icon: 'restore',\r\n                    tooltip: 'Reset the state (option store only)',\r\n                    action: (nodeId) => {\r\n                        const store = pinia._s.get(nodeId);\r\n                        if (!store) {\r\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\r\n                        }\r\n                        else if (!store._isOptionsAPI) {\r\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it's a setup store.`, 'warn');\r\n                        }\r\n                        else {\r\n                            store.$reset();\r\n                            toastMessage(`Store \"${nodeId}\" reset.`);\r\n                        }\r\n                    },\r\n                },\r\n            ],\r\n        });\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            const proxy = (payload.componentInstance &&\r\n                payload.componentInstance.proxy);\r\n            if (proxy && proxy._pStores) {\r\n                const piniaStores = payload.componentInstance.proxy._pStores;\r\n                Object.values(piniaStores).forEach((store) => {\r\n                    payload.instanceData.state.push({\r\n                        type: getStoreType(store.$id),\r\n                        key: 'state',\r\n                        editable: true,\r\n                        value: store._isOptionsAPI\r\n                            ? {\r\n                                _custom: {\r\n                                    value: toRaw(store.$state),\r\n                                    actions: [\r\n                                        {\r\n                                            icon: 'restore',\r\n                                            tooltip: 'Reset the state of this store',\r\n                                            action: () => store.$reset(),\r\n                                        },\r\n                                    ],\r\n                                },\r\n                            }\r\n                            : // NOTE: workaround to unwrap transferred refs\r\n                                Object.keys(store.$state).reduce((state, key) => {\r\n                                    state[key] = store.$state[key];\r\n                                    return state;\r\n                                }, {}),\r\n                    });\r\n                    if (store._getters && store._getters.length) {\r\n                        payload.instanceData.state.push({\r\n                            type: getStoreType(store.$id),\r\n                            key: 'getters',\r\n                            editable: false,\r\n                            value: store._getters.reduce((getters, key) => {\r\n                                try {\r\n                                    getters[key] = store[key];\r\n                                }\r\n                                catch (error) {\r\n                                    // @ts-expect-error: we just want to show it in devtools\r\n                                    getters[key] = error;\r\n                                }\r\n                                return getters;\r\n                            }, {}),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        api.on.getInspectorTree((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                let stores = [pinia];\r\n                stores = stores.concat(Array.from(pinia._s.values()));\r\n                payload.rootNodes = (payload.filter\r\n                    ? stores.filter((store) => '$id' in store\r\n                        ? store.$id\r\n                            .toLowerCase()\r\n                            .includes(payload.filter.toLowerCase())\r\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\r\n                    : stores).map(formatStoreForInspectorTree);\r\n            }\r\n        });\r\n        api.on.getInspectorState((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    // this could be the selected store restored for a different project\r\n                    // so it's better not to say anything here\r\n                    return;\r\n                }\r\n                if (inspectedStore) {\r\n                    payload.state = formatStoreForInspectorState(inspectedStore);\r\n                }\r\n            }\r\n        });\r\n        api.on.editInspectorState((payload, ctx) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (!isPinia(inspectedStore)) {\r\n                    // access only the state\r\n                    if (path.length !== 1 ||\r\n                        !inspectedStore._customProperties.has(path[0]) ||\r\n                        path[0] in inspectedStore.$state) {\r\n                        path.unshift('$state');\r\n                    }\r\n                }\r\n                else {\r\n                    // Root access, we can omit the `.value` because the devtools API does it for us\r\n                    path.unshift('state');\r\n                }\r\n                isTimelineActive = false;\r\n                payload.set(inspectedStore, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n        api.on.editComponentState((payload) => {\r\n            if (payload.type.startsWith('🍍')) {\r\n                const storeId = payload.type.replace(/^🍍\\s*/, '');\r\n                const store = pinia._s.get(storeId);\r\n                if (!store) {\r\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (path[0] !== 'state') {\r\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\r\n                }\r\n                // rewrite the first entry to be able to directly set the state as\r\n                // well as any other path\r\n                path[0] = '$state';\r\n                isTimelineActive = false;\r\n                payload.set(store, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addStoreToDevtools(app, store) {\r\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\r\n        componentStateTypes.push(getStoreType(store.$id));\r\n    }\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia 🍍',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n        settings: {\r\n            logStoreChanges: {\r\n                label: 'Notify about new/deleted stores',\r\n                type: 'boolean',\r\n                defaultValue: true,\r\n            },\r\n            // useEmojis: {\r\n            //   label: 'Use emojis in messages ⚡️',\r\n            //   type: 'boolean',\r\n            //   defaultValue: true,\r\n            // },\r\n        },\r\n    }, (api) => {\r\n        // gracefully handle errors\r\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\r\n        store.$onAction(({ after, onError, name, args }) => {\r\n            const groupId = runningActionId++;\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: '🛫 ' + name,\r\n                    subtitle: 'start',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        action: formatDisplay(name),\r\n                        args,\r\n                    },\r\n                    groupId,\r\n                },\r\n            });\r\n            after((result) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        title: '🛬 ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            result,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n            onError((error) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        logType: 'error',\r\n                        title: '💥 ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            error,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n        }, true);\r\n        store._customProperties.forEach((name) => {\r\n            watch(() => unref(store[name]), (newValue, oldValue) => {\r\n                api.notifyComponentUpdate();\r\n                api.sendInspectorState(INSPECTOR_ID);\r\n                if (isTimelineActive) {\r\n                    api.addTimelineEvent({\r\n                        layerId: MUTATIONS_LAYER_ID,\r\n                        event: {\r\n                            time: now(),\r\n                            title: 'Change',\r\n                            subtitle: name,\r\n                            data: {\r\n                                newValue,\r\n                                oldValue,\r\n                            },\r\n                            groupId: activeAction,\r\n                        },\r\n                    });\r\n                }\r\n            }, { deep: true });\r\n        });\r\n        store.$subscribe(({ events, type }, state) => {\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            if (!isTimelineActive)\r\n                return;\r\n            // rootStore.state[store.id] = state\r\n            const eventData = {\r\n                time: now(),\r\n                title: formatMutationType(type),\r\n                data: {\r\n                    store: formatDisplay(store.$id),\r\n                    ...formatEventData(events),\r\n                },\r\n                groupId: activeAction,\r\n            };\r\n            // reset for the next mutation\r\n            activeAction = undefined;\r\n            if (type === MutationType.patchFunction) {\r\n                eventData.subtitle = '⤵️';\r\n            }\r\n            else if (type === MutationType.patchObject) {\r\n                eventData.subtitle = '🧩';\r\n            }\r\n            else if (events && !Array.isArray(events)) {\r\n                eventData.subtitle = events.type;\r\n            }\r\n            if (events) {\r\n                eventData.data['rawEvent(s)'] = {\r\n                    _custom: {\r\n                        display: 'DebuggerEvent',\r\n                        type: 'object',\r\n                        tooltip: 'raw DebuggerEvent[]',\r\n                        value: events,\r\n                    },\r\n                };\r\n            }\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: eventData,\r\n            });\r\n        }, { detached: true, flush: 'sync' });\r\n        const hotUpdate = store._hotUpdate;\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            hotUpdate(newStore);\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: '🔥 ' + store.$id,\r\n                    subtitle: 'HMR update',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        info: formatDisplay(`HMR update`),\r\n                    },\r\n                },\r\n            });\r\n            // update the devtools too\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n        });\r\n        const { $dispose } = store;\r\n        store.$dispose = () => {\r\n            $dispose();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            api.getSettings().logStoreChanges &&\r\n                toastMessage(`Disposed \"${store.$id}\" store 🗑`);\r\n        };\r\n        // trigger an update so it can display new registered stores\r\n        api.notifyComponentUpdate();\r\n        api.sendInspectorTree(INSPECTOR_ID);\r\n        api.sendInspectorState(INSPECTOR_ID);\r\n        api.getSettings().logStoreChanges &&\r\n            toastMessage(`\"${store.$id}\" store installed 🆕`);\r\n    });\r\n}\r\nlet runningActionId = 0;\r\nlet activeAction;\r\n/**\r\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\r\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\r\n * mutation to the action.\r\n *\r\n * @param store - store to patch\r\n * @param actionNames - list of actionst to patch\r\n */\r\nfunction patchActionForGrouping(store, actionNames) {\r\n    // original actions of the store as they are given by pinia. We are going to override them\r\n    const actions = actionNames.reduce((storeActions, actionName) => {\r\n        // use toRaw to avoid tracking #541\r\n        storeActions[actionName] = toRaw(store)[actionName];\r\n        return storeActions;\r\n    }, {});\r\n    for (const actionName in actions) {\r\n        store[actionName] = function () {\r\n            // setActivePinia(store._p)\r\n            // the running action id is incremented in a before action hook\r\n            const _actionId = runningActionId;\r\n            const trackedStore = new Proxy(store, {\r\n                get(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.get(...args);\r\n                },\r\n                set(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.set(...args);\r\n                },\r\n            });\r\n            return actions[actionName].apply(trackedStore, arguments);\r\n        };\r\n    }\r\n}\r\n/**\r\n * pinia.use(devtoolsPlugin)\r\n */\r\nfunction devtoolsPlugin({ app, store, options }) {\r\n    // HMR module\r\n    if (store.$id.startsWith('__hot:')) {\r\n        return;\r\n    }\r\n    // detect option api vs setup api\r\n    if (options.state) {\r\n        store._isOptionsAPI = true;\r\n    }\r\n    // only wrap actions in option-defined stores as this technique relies on\r\n    // wrapping the context of the action with a proxy\r\n    if (typeof options.state === 'function') {\r\n        patchActionForGrouping(\r\n        // @ts-expect-error: can cast the store...\r\n        store, Object.keys(options.actions));\r\n        const originalHotUpdate = store._hotUpdate;\r\n        // Upgrade the HMR to also update the new actions\r\n        toRaw(store)._hotUpdate = function (newStore) {\r\n            originalHotUpdate.apply(this, arguments);\r\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));\r\n        };\r\n    }\r\n    addStoreToDevtools(app, \r\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\r\n    store);\r\n}\n\n/**\r\n * Creates a Pinia instance to be used by the application\r\n */\r\nfunction createPinia() {\r\n    const scope = effectScope(true);\r\n    // NOTE: here we could check the window object for a state and directly set it\r\n    // if there is anything like it with Vue 3 SSR\r\n    const state = scope.run(() => ref({}));\r\n    let _p = [];\r\n    // plugins added before calling app.use(pinia)\r\n    let toBeInstalled = [];\r\n    const pinia = markRaw({\r\n        install(app) {\r\n            // this allows calling useStore() outside of a component setup after\r\n            // installing pinia's plugin\r\n            setActivePinia(pinia);\r\n            if (!isVue2) {\r\n                pinia._a = app;\r\n                app.provide(piniaSymbol, pinia);\r\n                app.config.globalProperties.$pinia = pinia;\r\n                /* istanbul ignore else */\r\n                if (USE_DEVTOOLS) {\r\n                    registerPiniaDevtools(app, pinia);\r\n                }\r\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\r\n                toBeInstalled = [];\r\n            }\r\n        },\r\n        use(plugin) {\r\n            if (!this._a && !isVue2) {\r\n                toBeInstalled.push(plugin);\r\n            }\r\n            else {\r\n                _p.push(plugin);\r\n            }\r\n            return this;\r\n        },\r\n        _p,\r\n        // it's actually undefined here\r\n        // @ts-expect-error\r\n        _a: null,\r\n        _e: scope,\r\n        _s: new Map(),\r\n        state,\r\n    });\r\n    // pinia devtools rely on dev only features so they cannot be forced unless\r\n    // the dev build of Vue is used. Avoid old browsers like IE11.\r\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\r\n        pinia.use(devtoolsPlugin);\r\n    }\r\n    return pinia;\r\n}\n\n/**\r\n * Checks if a function is a `StoreDefinition`.\r\n *\r\n * @param fn - object to test\r\n * @returns true if `fn` is a StoreDefinition\r\n */\r\nconst isUseStore = (fn) => {\r\n    return typeof fn === 'function' && typeof fn.$id === 'string';\r\n};\r\n/**\r\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\r\n * remove any key not existing in `newState` and recursively merge plain\r\n * objects.\r\n *\r\n * @param newState - new state object to be patched\r\n * @param oldState - old state that should be used to patch newState\r\n * @returns - newState\r\n */\r\nfunction patchObject(newState, oldState) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in oldState) {\r\n        const subPatch = oldState[key];\r\n        // skip the whole sub tree\r\n        if (!(key in newState)) {\r\n            continue;\r\n        }\r\n        const targetValue = newState[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            newState[key] = patchObject(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\r\n            // just set the whole thing\r\n            if (isVue2) {\r\n                set(newState, key, subPatch);\r\n            }\r\n            else {\r\n                newState[key] = subPatch;\r\n            }\r\n        }\r\n    }\r\n    return newState;\r\n}\r\n/**\r\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\r\n *\r\n * @example\r\n * ```js\r\n * const useUser = defineStore(...)\r\n * if (import.meta.hot) {\r\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\r\n * }\r\n * ```\r\n *\r\n * @param initialUseStore - return of the defineStore to hot update\r\n * @param hot - `import.meta.hot`\r\n */\r\nfunction acceptHMRUpdate(initialUseStore, hot) {\r\n    // strip as much as possible from iife.prod\r\n    if (!(process.env.NODE_ENV !== 'production')) {\r\n        return () => { };\r\n    }\r\n    return (newModule) => {\r\n        const pinia = hot.data.pinia || initialUseStore._pinia;\r\n        if (!pinia) {\r\n            // this store is still not used\r\n            return;\r\n        }\r\n        // preserve the pinia instance across loads\r\n        hot.data.pinia = pinia;\r\n        // console.log('got data', newStore)\r\n        for (const exportName in newModule) {\r\n            const useStore = newModule[exportName];\r\n            // console.log('checking for', exportName)\r\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\r\n                // console.log('Accepting update for', useStore.$id)\r\n                const id = useStore.$id;\r\n                if (id !== initialUseStore.$id) {\r\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\r\n                    // return import.meta.hot.invalidate()\r\n                    return hot.invalidate();\r\n                }\r\n                const existingStore = pinia._s.get(id);\r\n                if (!existingStore) {\r\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\r\n                    return;\r\n                }\r\n                useStore(pinia, existingStore);\r\n            }\r\n        }\r\n    };\r\n}\n\nconst noop = () => { };\r\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\r\n    subscriptions.push(callback);\r\n    const removeSubscription = () => {\r\n        const idx = subscriptions.indexOf(callback);\r\n        if (idx > -1) {\r\n            subscriptions.splice(idx, 1);\r\n            onCleanup();\r\n        }\r\n    };\r\n    if (!detached && getCurrentScope()) {\r\n        onScopeDispose(removeSubscription);\r\n    }\r\n    return removeSubscription;\r\n}\r\nfunction triggerSubscriptions(subscriptions, ...args) {\r\n    subscriptions.slice().forEach((callback) => {\r\n        callback(...args);\r\n    });\r\n}\n\nfunction mergeReactiveObjects(target, patchToApply) {\r\n    // Handle Map instances\r\n    if (target instanceof Map && patchToApply instanceof Map) {\r\n        patchToApply.forEach((value, key) => target.set(key, value));\r\n    }\r\n    // Handle Set instances\r\n    if (target instanceof Set && patchToApply instanceof Set) {\r\n        patchToApply.forEach(target.add, target);\r\n    }\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in patchToApply) {\r\n        if (!patchToApply.hasOwnProperty(key))\r\n            continue;\r\n        const subPatch = patchToApply[key];\r\n        const targetValue = target[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            target.hasOwnProperty(key) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\r\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\r\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\r\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // @ts-expect-error: subPatch is a valid value\r\n            target[key] = subPatch;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\r\n    ? Symbol('pinia:skipHydration')\r\n    : /* istanbul ignore next */ Symbol();\r\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\r\n/**\r\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\r\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\r\n *\r\n * @param obj - target object\r\n * @returns obj\r\n */\r\nfunction skipHydrate(obj) {\r\n    return isVue2\r\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\r\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\r\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\r\n}\r\n/**\r\n * Returns whether a value should be hydrated\r\n *\r\n * @param obj - target variable\r\n * @returns true if `obj` should be hydrated\r\n */\r\nfunction shouldHydrate(obj) {\r\n    return isVue2\r\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\r\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\r\n}\r\nconst { assign } = Object;\r\nfunction isComputed(o) {\r\n    return !!(isRef(o) && o.effect);\r\n}\r\nfunction createOptionsStore(id, options, pinia, hot) {\r\n    const { state, actions, getters } = options;\r\n    const initialState = pinia.state.value[id];\r\n    let store;\r\n    function setup() {\r\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(pinia.state.value, id, state ? state() : {});\r\n            }\r\n            else {\r\n                pinia.state.value[id] = state ? state() : {};\r\n            }\r\n        }\r\n        // avoid creating a state in pinia.state.value\r\n        const localState = (process.env.NODE_ENV !== 'production') && hot\r\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\r\n                toRefs(ref(state ? state() : {}).value)\r\n            : toRefs(pinia.state.value[id]);\r\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\r\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\r\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\r\n            }\r\n            computedGetters[name] = markRaw(computed(() => {\r\n                setActivePinia(pinia);\r\n                // it was created just before\r\n                const store = pinia._s.get(id);\r\n                // allow cross using stores\r\n                /* istanbul ignore next */\r\n                if (isVue2 && !store._r)\r\n                    return;\r\n                // @ts-expect-error\r\n                // return getters![name].call(context, context)\r\n                // TODO: avoid reading the getter while assigning with a global variable\r\n                return getters[name].call(store, store);\r\n            }));\r\n            return computedGetters;\r\n        }, {}));\r\n    }\r\n    store = createSetupStore(id, setup, options, pinia, hot, true);\r\n    store.$reset = function $reset() {\r\n        const newState = state ? state() : {};\r\n        // we use a patch to group all changes into one single subscription\r\n        this.$patch(($state) => {\r\n            assign($state, newState);\r\n        });\r\n    };\r\n    return store;\r\n}\r\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\r\n    let scope;\r\n    const optionsForPlugin = assign({ actions: {} }, options);\r\n    /* istanbul ignore if */\r\n    // @ts-expect-error: active is an internal property\r\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\r\n        throw new Error('Pinia destroyed');\r\n    }\r\n    // watcher options for $subscribe\r\n    const $subscribeOptions = {\r\n        deep: true,\r\n        // flush: 'post',\r\n    };\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\r\n        $subscribeOptions.onTrigger = (event) => {\r\n            /* istanbul ignore else */\r\n            if (isListening) {\r\n                debuggerEvents = event;\r\n                // avoid triggering this while the store is being built and the state is being set in pinia\r\n            }\r\n            else if (isListening == false && !store._hotUpdating) {\r\n                // let patch send all the events together later\r\n                /* istanbul ignore else */\r\n                if (Array.isArray(debuggerEvents)) {\r\n                    debuggerEvents.push(event);\r\n                }\r\n                else {\r\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    // internal state\r\n    let isListening; // set to true at the end\r\n    let isSyncListening; // set to true at the end\r\n    let subscriptions = markRaw([]);\r\n    let actionSubscriptions = markRaw([]);\r\n    let debuggerEvents;\r\n    const initialState = pinia.state.value[$id];\r\n    // avoid setting the state for option stores if it is set\r\n    // by the setup\r\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n        /* istanbul ignore if */\r\n        if (isVue2) {\r\n            set(pinia.state.value, $id, {});\r\n        }\r\n        else {\r\n            pinia.state.value[$id] = {};\r\n        }\r\n    }\r\n    const hotState = ref({});\r\n    // avoid triggering too many listeners\r\n    // https://github.com/vuejs/pinia/issues/1129\r\n    let activeListener;\r\n    function $patch(partialStateOrMutator) {\r\n        let subscriptionMutation;\r\n        isListening = isSyncListening = false;\r\n        // reset the debugger events since patches are sync\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            debuggerEvents = [];\r\n        }\r\n        if (typeof partialStateOrMutator === 'function') {\r\n            partialStateOrMutator(pinia.state.value[$id]);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchFunction,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        else {\r\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchObject,\r\n                payload: partialStateOrMutator,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        const myListenerId = (activeListener = Symbol());\r\n        nextTick().then(() => {\r\n            if (activeListener === myListenerId) {\r\n                isListening = true;\r\n            }\r\n        });\r\n        isSyncListening = true;\r\n        // because we paused the watcher, we need to manually call the subscriptions\r\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\r\n    }\r\n    /* istanbul ignore next */\r\n    const $reset = (process.env.NODE_ENV !== 'production')\r\n        ? () => {\r\n            throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\r\n        }\r\n        : noop;\r\n    function $dispose() {\r\n        scope.stop();\r\n        subscriptions = [];\r\n        actionSubscriptions = [];\r\n        pinia._s.delete($id);\r\n    }\r\n    /**\r\n     * Wraps an action to handle subscriptions.\r\n     *\r\n     * @param name - name of the action\r\n     * @param action - action to wrap\r\n     * @returns a wrapped action to handle subscriptions\r\n     */\r\n    function wrapAction(name, action) {\r\n        return function () {\r\n            setActivePinia(pinia);\r\n            const args = Array.from(arguments);\r\n            const afterCallbackList = [];\r\n            const onErrorCallbackList = [];\r\n            function after(callback) {\r\n                afterCallbackList.push(callback);\r\n            }\r\n            function onError(callback) {\r\n                onErrorCallbackList.push(callback);\r\n            }\r\n            // @ts-expect-error\r\n            triggerSubscriptions(actionSubscriptions, {\r\n                args,\r\n                name,\r\n                store,\r\n                after,\r\n                onError,\r\n            });\r\n            let ret;\r\n            try {\r\n                ret = action.apply(this && this.$id === $id ? this : store, args);\r\n                // handle sync errors\r\n            }\r\n            catch (error) {\r\n                triggerSubscriptions(onErrorCallbackList, error);\r\n                throw error;\r\n            }\r\n            if (ret instanceof Promise) {\r\n                return ret\r\n                    .then((value) => {\r\n                    triggerSubscriptions(afterCallbackList, value);\r\n                    return value;\r\n                })\r\n                    .catch((error) => {\r\n                    triggerSubscriptions(onErrorCallbackList, error);\r\n                    return Promise.reject(error);\r\n                });\r\n            }\r\n            // allow the afterCallback to override the return value\r\n            triggerSubscriptions(afterCallbackList, ret);\r\n            return ret;\r\n        };\r\n    }\r\n    const _hmrPayload = /*#__PURE__*/ markRaw({\r\n        actions: {},\r\n        getters: {},\r\n        state: [],\r\n        hotState,\r\n    });\r\n    const partialStore = {\r\n        _p: pinia,\r\n        // _s: scope,\r\n        $id,\r\n        $onAction: addSubscription.bind(null, actionSubscriptions),\r\n        $patch,\r\n        $reset,\r\n        $subscribe(callback, options = {}) {\r\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\r\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\r\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\r\n                    callback({\r\n                        storeId: $id,\r\n                        type: MutationType.direct,\r\n                        events: debuggerEvents,\r\n                    }, state);\r\n                }\r\n            }, assign({}, $subscribeOptions, options)));\r\n            return removeSubscription;\r\n        },\r\n        $dispose,\r\n    };\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // start as non ready\r\n        partialStore._r = false;\r\n    }\r\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\r\n        ? assign({\r\n            _hmrPayload,\r\n            _customProperties: markRaw(new Set()), // devtools custom properties\r\n        }, partialStore\r\n        // must be added later\r\n        // setupStore\r\n        )\r\n        : partialStore);\r\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\r\n    // creating infinite loops.\r\n    pinia._s.set($id, store);\r\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\r\n    const setupStore = pinia._e.run(() => {\r\n        scope = effectScope();\r\n        return scope.run(() => setup());\r\n    });\r\n    // overwrite existing actions to support $onAction\r\n    for (const key in setupStore) {\r\n        const prop = setupStore[key];\r\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\r\n            // mark it as a piece of state to be serialized\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                set(hotState.value, key, toRef(setupStore, key));\r\n                // createOptionStore directly sets the state in pinia.state.value so we\r\n                // can just skip that\r\n            }\r\n            else if (!isOptionsStore) {\r\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\r\n                if (initialState && shouldHydrate(prop)) {\r\n                    if (isRef(prop)) {\r\n                        prop.value = initialState[key];\r\n                    }\r\n                    else {\r\n                        // probably a reactive object, lets recursively assign\r\n                        // @ts-expect-error: prop is unknown\r\n                        mergeReactiveObjects(prop, initialState[key]);\r\n                    }\r\n                }\r\n                // transfer the ref to the pinia state to keep everything in sync\r\n                /* istanbul ignore if */\r\n                if (isVue2) {\r\n                    set(pinia.state.value[$id], key, prop);\r\n                }\r\n                else {\r\n                    pinia.state.value[$id][key] = prop;\r\n                }\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.state.push(key);\r\n            }\r\n            // action\r\n        }\r\n        else if (typeof prop === 'function') {\r\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\r\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\r\n            // this a hot module replacement store because the hotUpdate method needs\r\n            // to do it with the right context\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(setupStore, key, actionValue);\r\n            }\r\n            else {\r\n                // @ts-expect-error\r\n                setupStore[key] = actionValue;\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.actions[key] = prop;\r\n            }\r\n            // list actions so they can be used in plugins\r\n            // @ts-expect-error\r\n            optionsForPlugin.actions[key] = prop;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            // add getters for devtools\r\n            if (isComputed(prop)) {\r\n                _hmrPayload.getters[key] = isOptionsStore\r\n                    ? // @ts-expect-error\r\n                        options.getters[key]\r\n                    : prop;\r\n                if (IS_CLIENT) {\r\n                    const getters = setupStore._getters ||\r\n                        // @ts-expect-error: same\r\n                        (setupStore._getters = markRaw([]));\r\n                    getters.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // add the state, getters, and action properties\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        Object.keys(setupStore).forEach((key) => {\r\n            set(store, key, setupStore[key]);\r\n        });\r\n    }\r\n    else {\r\n        assign(store, setupStore);\r\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\r\n        // Make `storeToRefs()` work with `reactive()` #799\r\n        assign(toRaw(store), setupStore);\r\n    }\r\n    // use this instead of a computed with setter to be able to create it anywhere\r\n    // without linking the computed lifespan to wherever the store is first\r\n    // created.\r\n    Object.defineProperty(store, '$state', {\r\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\r\n        set: (state) => {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                throw new Error('cannot set hotState');\r\n            }\r\n            $patch(($state) => {\r\n                assign($state, state);\r\n            });\r\n        },\r\n    });\r\n    // add the hotUpdate before plugins to allow them to override it\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            store._hotUpdating = true;\r\n            newStore._hmrPayload.state.forEach((stateKey) => {\r\n                if (stateKey in store.$state) {\r\n                    const newStateTarget = newStore.$state[stateKey];\r\n                    const oldStateSource = store.$state[stateKey];\r\n                    if (typeof newStateTarget === 'object' &&\r\n                        isPlainObject(newStateTarget) &&\r\n                        isPlainObject(oldStateSource)) {\r\n                        patchObject(newStateTarget, oldStateSource);\r\n                    }\r\n                    else {\r\n                        // transfer the ref\r\n                        newStore.$state[stateKey] = oldStateSource;\r\n                    }\r\n                }\r\n                // patch direct access properties to allow store.stateProperty to work as\r\n                // store.$state.stateProperty\r\n                set(store, stateKey, toRef(newStore.$state, stateKey));\r\n            });\r\n            // remove deleted state properties\r\n            Object.keys(store.$state).forEach((stateKey) => {\r\n                if (!(stateKey in newStore.$state)) {\r\n                    del(store, stateKey);\r\n                }\r\n            });\r\n            // avoid devtools logging this as a mutation\r\n            isListening = false;\r\n            isSyncListening = false;\r\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\r\n            isSyncListening = true;\r\n            nextTick().then(() => {\r\n                isListening = true;\r\n            });\r\n            for (const actionName in newStore._hmrPayload.actions) {\r\n                const action = newStore[actionName];\r\n                set(store, actionName, wrapAction(actionName, action));\r\n            }\r\n            // TODO: does this work in both setup and option store?\r\n            for (const getterName in newStore._hmrPayload.getters) {\r\n                const getter = newStore._hmrPayload.getters[getterName];\r\n                const getterValue = isOptionsStore\r\n                    ? // special handling of options api\r\n                        computed(() => {\r\n                            setActivePinia(pinia);\r\n                            return getter.call(store, store);\r\n                        })\r\n                    : getter;\r\n                set(store, getterName, getterValue);\r\n            }\r\n            // remove deleted getters\r\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.getters)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // remove old actions\r\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.actions)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // update the values used in devtools and to allow deleting new properties later on\r\n            store._hmrPayload = newStore._hmrPayload;\r\n            store._getters = newStore._getters;\r\n            store._hotUpdating = false;\r\n        });\r\n    }\r\n    if (USE_DEVTOOLS) {\r\n        const nonEnumerable = {\r\n            writable: true,\r\n            configurable: true,\r\n            // avoid warning on devtools trying to display this property\r\n            enumerable: false,\r\n        };\r\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\r\n            Object.defineProperty(store, p, {\r\n                value: store[p],\r\n                ...nonEnumerable,\r\n            });\r\n        });\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // mark the store as ready before plugins\r\n        store._r = true;\r\n    }\r\n    // apply all plugins\r\n    pinia._p.forEach((extender) => {\r\n        /* istanbul ignore else */\r\n        if (USE_DEVTOOLS) {\r\n            const extensions = scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            }));\r\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\r\n            assign(store, extensions);\r\n        }\r\n        else {\r\n            assign(store, scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            })));\r\n        }\r\n    });\r\n    if ((process.env.NODE_ENV !== 'production') &&\r\n        store.$state &&\r\n        typeof store.$state === 'object' &&\r\n        typeof store.$state.constructor === 'function' &&\r\n        !store.$state.constructor.toString().includes('[native code]')) {\r\n        console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\r\n            `\\tstate: () => new MyClass()\\n` +\r\n            `Found in store \"${store.$id}\".`);\r\n    }\r\n    // only apply hydrate to option stores with an initial state in pinia\r\n    if (initialState &&\r\n        isOptionsStore &&\r\n        options.hydrate) {\r\n        options.hydrate(store.$state, initialState);\r\n    }\r\n    isListening = true;\r\n    isSyncListening = true;\r\n    return store;\r\n}\r\nfunction defineStore(\r\n// TODO: add proper types from above\r\nidOrOptions, setup, setupOptions) {\r\n    let id;\r\n    let options;\r\n    const isSetupStore = typeof setup === 'function';\r\n    if (typeof idOrOptions === 'string') {\r\n        id = idOrOptions;\r\n        // the option store setup will contain the actual options in this case\r\n        options = isSetupStore ? setupOptions : setup;\r\n    }\r\n    else {\r\n        options = idOrOptions;\r\n        id = idOrOptions.id;\r\n    }\r\n    function useStore(pinia, hot) {\r\n        const currentInstance = getCurrentInstance();\r\n        pinia =\r\n            // in test mode, ignore the argument provided as we can always retrieve a\r\n            // pinia instance with getActivePinia()\r\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\r\n                (currentInstance && inject(piniaSymbol));\r\n        if (pinia)\r\n            setActivePinia(pinia);\r\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\r\n            throw new Error(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n` +\r\n                `\\tconst pinia = createPinia()\\n` +\r\n                `\\tapp.use(pinia)\\n` +\r\n                `This will fail in production.`);\r\n        }\r\n        pinia = activePinia;\r\n        if (!pinia._s.has(id)) {\r\n            // creating the store registers it in `pinia._s`\r\n            if (isSetupStore) {\r\n                createSetupStore(id, setup, options, pinia);\r\n            }\r\n            else {\r\n                createOptionsStore(id, options, pinia);\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                // @ts-expect-error: not the right inferred type\r\n                useStore._pinia = pinia;\r\n            }\r\n        }\r\n        const store = pinia._s.get(id);\r\n        if ((process.env.NODE_ENV !== 'production') && hot) {\r\n            const hotId = '__hot:' + id;\r\n            const newStore = isSetupStore\r\n                ? createSetupStore(hotId, setup, options, pinia, true)\r\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\r\n            hot._hotUpdate(newStore);\r\n            // cleanup the state properties and the store from the cache\r\n            delete pinia.state.value[hotId];\r\n            pinia._s.delete(hotId);\r\n        }\r\n        // save stores in instances to access them devtools\r\n        if ((process.env.NODE_ENV !== 'production') &&\r\n            IS_CLIENT &&\r\n            currentInstance &&\r\n            currentInstance.proxy &&\r\n            // avoid adding stores that are just built for hot module replacement\r\n            !hot) {\r\n            const vm = currentInstance.proxy;\r\n            const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\r\n            cache[id] = store;\r\n        }\r\n        // StoreGeneric cannot be casted towards Store\r\n        return store;\r\n    }\r\n    useStore.$id = id;\r\n    return useStore;\r\n}\n\nlet mapStoreSuffix = 'Store';\r\n/**\r\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\r\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\r\n * interface if you are using TypeScript.\r\n *\r\n * @param suffix - new suffix\r\n */\r\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\r\n) {\r\n    mapStoreSuffix = suffix;\r\n}\r\n/**\r\n * Allows using stores without the composition API (`setup()`) by generating an\r\n * object to be spread in the `computed` field of a component. It accepts a list\r\n * of store definitions.\r\n *\r\n * @example\r\n * ```js\r\n * export default {\r\n *   computed: {\r\n *     // other computed properties\r\n *     ...mapStores(useUserStore, useCartStore)\r\n *   },\r\n *\r\n *   created() {\r\n *     this.userStore // store with id \"user\"\r\n *     this.cartStore // store with id \"cart\"\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @param stores - list of stores to map to an object\r\n */\r\nfunction mapStores(...stores) {\r\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\r\n        console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\r\n            `Replace\\n` +\r\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\r\n            `with\\n` +\r\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\r\n            `This will fail in production if not fixed.`);\r\n        stores = stores[0];\r\n    }\r\n    return stores.reduce((reduced, useStore) => {\r\n        // @ts-expect-error: $id is added by defineStore\r\n        reduced[useStore.$id + mapStoreSuffix] = function () {\r\n            return useStore(this.$pinia);\r\n        };\r\n        return reduced;\r\n    }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            reduced[key] = function () {\r\n                return useStore(this.$pinia)[key];\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function () {\r\n                const store = useStore(this.$pinia);\r\n                const storeKey = keysOrMapper[key];\r\n                // for some reason TS is unable to infer the type of storeKey to be a\r\n                // function\r\n                return typeof storeKey === 'function'\r\n                    ? storeKey.call(this, store)\r\n                    : store[storeKey];\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Alias for `mapState()`. You should use `mapState()` instead.\r\n * @deprecated use `mapState()` instead.\r\n */\r\nconst mapGetters = mapState;\r\n/**\r\n * Allows directly using actions from your store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `methods` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapActions(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[key](...args);\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapWritableState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[key];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[key] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[keysOrMapper[key]];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\n\n/**\r\n * Creates an object of references with all the state, getters, and plugin-added\r\n * state properties of the store. Similar to `toRefs()` but specifically\r\n * designed for Pinia stores so methods and non reactive properties are\r\n * completely ignored.\r\n *\r\n * @param store - store to extract the refs from\r\n */\r\nfunction storeToRefs(store) {\r\n    // See https://github.com/vuejs/pinia/issues/852\r\n    // It's easier to just use toRefs() even if it includes more stuff\r\n    if (isVue2) {\r\n        // @ts-expect-error: toRefs include methods and others\r\n        return toRefs(store);\r\n    }\r\n    else {\r\n        store = toRaw(store);\r\n        const refs = {};\r\n        for (const key in store) {\r\n            const value = store[key];\r\n            if (isRef(value) || isReactive(value)) {\r\n                // @ts-expect-error: the key is state or getter\r\n                refs[key] =\r\n                    // ---\r\n                    toRef(store, key);\r\n            }\r\n        }\r\n        return refs;\r\n    }\r\n}\n\n/**\r\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\r\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\r\n * https://pinia.vuejs.org/ssr/nuxt.html.\r\n *\r\n * @example\r\n * ```js\r\n * import Vue from 'vue'\r\n * import { PiniaVuePlugin, createPinia } from 'pinia'\r\n *\r\n * Vue.use(PiniaVuePlugin)\r\n * const pinia = createPinia()\r\n *\r\n * new Vue({\r\n *   el: '#app',\r\n *   // ...\r\n *   pinia,\r\n * })\r\n * ```\r\n *\r\n * @param _Vue - `Vue` imported from 'vue'.\r\n */\r\nconst PiniaVuePlugin = function (_Vue) {\r\n    // Equivalent of\r\n    // app.config.globalProperties.$pinia = pinia\r\n    _Vue.mixin({\r\n        beforeCreate() {\r\n            const options = this.$options;\r\n            if (options.pinia) {\r\n                const pinia = options.pinia;\r\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\r\n                /* istanbul ignore else */\r\n                if (!this._provided) {\r\n                    const provideCache = {};\r\n                    Object.defineProperty(this, '_provided', {\r\n                        get: () => provideCache,\r\n                        set: (v) => Object.assign(provideCache, v),\r\n                    });\r\n                }\r\n                this._provided[piniaSymbol] = pinia;\r\n                // propagate the pinia instance in an SSR friendly way\r\n                // avoid adding it to nuxt twice\r\n                /* istanbul ignore else */\r\n                if (!this.$pinia) {\r\n                    this.$pinia = pinia;\r\n                }\r\n                pinia._a = this;\r\n                if (IS_CLIENT) {\r\n                    // this allows calling useStore() outside of a component setup after\r\n                    // installing pinia's plugin\r\n                    setActivePinia(pinia);\r\n                }\r\n                if (USE_DEVTOOLS) {\r\n                    registerPiniaDevtools(pinia._a, pinia);\r\n                }\r\n            }\r\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\r\n                this.$pinia = options.parent.$pinia;\r\n            }\r\n        },\r\n        destroyed() {\r\n            delete this._pStores;\r\n        },\r\n    });\r\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n","import { createPinia, setActivePinia } from \"pinia\";\nimport { defineNuxtPlugin } from \"#app\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const pinia = createPinia();\n  nuxtApp.vueApp.use(pinia);\n  setActivePinia(pinia);\n  if (process.server) {\n    nuxtApp.payload.pinia = pinia.state.value;\n  } else if (nuxtApp.payload && nuxtApp.payload.pinia) {\n    pinia.state.value = nuxtApp.payload.pinia;\n  }\n  return {\n    provide: {\n      pinia\n    }\n  };\n});\n","import { defineAsyncComponent } from 'vue'\nimport { defineNuxtPlugin } from '#app'\n\nconst components = {}\n\nexport default defineNuxtPlugin(nuxtApp => {\n  for (const name in components) {\n    nuxtApp.vueApp.component(name, components[name])\n    nuxtApp.vueApp.component('Lazy' + name, components[name])\n  }\n})\n","import { createHooks } from 'hookable';\nimport { unref, isRef, version, getCurrentInstance, inject, nextTick, ref, watchEffect, watch, onBeforeUnmount } from 'vue';\n\nconst TagsWithInnerContent = [\"script\", \"style\", \"noscript\"];\nconst HasElementTags$1 = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\n\nconst UniqueTags$1 = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nfunction tagDedupeKey$1(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags$1.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst setAttrs = (ctx, markSideEffect) => {\n  const { tag, $el } = ctx;\n  if (!$el)\n    return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value)\n        return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect)\n          markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c))\n          $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\"))\n      markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if ($el.getAttribute(k) !== value)\n      $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag) && $el.innerHTML !== (tag.children || \"\"))\n    $el.innerHTML = tag.children || \"\";\n};\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\n\nasync function renderDOMHead(head, options = {}) {\n  const ctx = { shouldRender: true };\n  await head.hooks.callHook(\"dom:beforeRender\", ctx);\n  if (!ctx.shouldRender)\n    return;\n  const dom = options.document || window.document;\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map((entry) => entry._sde).forEach((sde) => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const preRenderTag = async (tag) => {\n    const entry = head.headEntries().find((e) => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashCode(JSON.stringify({ ...tag, _e: void 0, _p: void 0 })),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      staleSideEffects\n    };\n    await head.hooks.callHook(\"dom:beforeRenderTag\", renderCtx);\n    return renderCtx;\n  };\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markSideEffect = (ctx2, key, fn) => {\n    key = `${ctx2.renderId}:${key}`;\n    if (ctx2.entry)\n      ctx2.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  const markEl = (ctx2) => {\n    head._elMap[ctx2.renderId] = ctx2.$el;\n    renders.push(ctx2);\n    markSideEffect(ctx2, \"el\", () => {\n      ctx2.$el?.remove();\n      delete head._elMap[ctx2.renderId];\n    });\n  };\n  for (const t of await head.resolveTags()) {\n    const ctx2 = await preRenderTag(t);\n    if (!ctx2.shouldRender)\n      continue;\n    const { tag } = ctx2;\n    if (tag.tag === \"title\") {\n      dom.title = tag.children || \"\";\n      renders.push(ctx2);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx2.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx2, markSideEffect);\n      renders.push(ctx2);\n      continue;\n    }\n    ctx2.$el = head._elMap[ctx2.renderId];\n    if (!ctx2.$el && tag._hash) {\n      ctx2.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._hash}]`);\n    }\n    if (ctx2.$el) {\n      if (ctx2.tag._d)\n        setAttrs(ctx2);\n      markEl(ctx2);\n      continue;\n    }\n    ctx2.$el = dom.createElement(tag.tag);\n    setAttrs(ctx2);\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx2);\n  }\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length)\n      return;\n    for (const $el of [...dom[pos].children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags$1.includes(elTag))\n        continue;\n      const dedupeKey = tagDedupeKey$1({\n        tag: elTag,\n        props: $el.getAttributeNames().reduce((props, name) => ({ ...props, [name]: $el.getAttribute(name) }), {})\n      });\n      const matchIdx = queue.findIndex((ctx2) => ctx2 && (ctx2.tag._d === dedupeKey || $el.isEqualNode(ctx2.$el)));\n      if (matchIdx !== -1) {\n        const ctx2 = queue[matchIdx];\n        ctx2.$el = $el;\n        setAttrs(ctx2);\n        markEl(ctx2);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach((ctx2) => {\n      if (!ctx2.$el)\n        return;\n      switch (ctx2.tag.tagPosition) {\n        case \"bodyClose\":\n          dom.body.appendChild(ctx2.$el);\n          break;\n        case \"bodyOpen\":\n          dom.body.insertBefore(ctx2.$el, dom.body.firstChild);\n          break;\n        case \"head\":\n        default:\n          dom.head.appendChild(ctx2.$el);\n          break;\n      }\n      markEl(ctx2);\n    });\n  });\n  for (const ctx2 of renders)\n    await head.hooks.callHook(\"dom:renderTag\", ctx2);\n  Object.values(staleSideEffects).forEach((fn) => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || ((fn) => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise((resolve) => delayFn(() => resolve(doDomUpdate())));\n}\n\nconst index = {\n  __proto__: null,\n  debouncedRenderDOMHead: debouncedRenderDOMHead,\n  get domUpdatePromise () { return domUpdatePromise; },\n  hashCode: hashCode,\n  renderDOMHead: renderDOMHead\n};\n\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\"];\n\nasync function normaliseTag(tagName, input) {\n  const tag = { tag: tagName, props: {} };\n  if (tagName === \"title\" || tagName === \"titleTemplate\") {\n    tag.children = input instanceof Promise ? await input : input;\n    return tag;\n  }\n  tag.props = await normaliseProps({ ...input });\n  [\"children\", \"innerHtml\", \"innerHTML\"].forEach((key) => {\n    if (typeof tag.props[key] !== \"undefined\") {\n      tag.children = tag.props[key];\n      delete tag.props[key];\n    }\n  });\n  Object.keys(tag.props).filter((k) => TagConfigKeys.includes(k)).forEach((k) => {\n    tag[k] = tag.props[k];\n    delete tag.props[k];\n  });\n  if (typeof tag.props.class === \"object\" && !Array.isArray(tag.props.class)) {\n    tag.props.class = Object.keys(tag.props.class).filter((k) => tag.props.class[k]);\n  }\n  if (Array.isArray(tag.props.class))\n    tag.props.class = tag.props.class.join(\" \");\n  if (tag.props.content && Array.isArray(tag.props.content)) {\n    return tag.props.content.map((v, i) => {\n      const newTag = { ...tag, props: { ...tag.props } };\n      newTag.props.content = v;\n      newTag.key = `${tag.props.name || tag.props.property}:${i}`;\n      return newTag;\n    });\n  }\n  return tag;\n}\nasync function normaliseProps(props) {\n  for (const k of Object.keys(props)) {\n    if (props[k] instanceof Promise) {\n      props[k] = await props[k];\n    }\n    if (String(props[k]) === \"true\") {\n      props[k] = \"\";\n    } else if (String(props[k]) === \"false\") {\n      delete props[k];\n    }\n  }\n  return props;\n}\n\nconst tagWeight = (tag) => {\n  if (typeof tag.tagPriority === \"number\")\n    return tag.tagPriority;\n  switch (tag.tagPriority) {\n    case \"critical\":\n      return 2;\n    case \"high\":\n      return 9;\n    case \"low\":\n      return 12;\n  }\n  switch (tag.tag) {\n    case \"base\":\n      return -1;\n    case \"title\":\n      return 1;\n    case \"meta\":\n      if (tag.props.charset)\n        return -2;\n      if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n        return 0;\n      return 10;\n    default:\n      return 10;\n  }\n};\nconst sortTags = (aTag, bTag) => {\n  return tagWeight(aTag) - tagWeight(bTag);\n};\n\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst renderTitleTemplate = (template, title) => {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template.replace(\"%s\", title ?? \"\");\n};\nfunction resolveTitleTemplateFromTags(tags) {\n  let titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n  const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n  if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children,\n      tags[titleIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleIdx].children = newTitle || tags[titleIdx].children;\n    } else {\n      delete tags[titleIdx];\n    }\n  } else if (titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleTemplateIdx].children = newTitle;\n      tags[titleTemplateIdx].tag = \"title\";\n      titleTemplateIdx = -1;\n    }\n  }\n  if (titleTemplateIdx !== -1) {\n    delete tags[titleTemplateIdx];\n  }\n  return tags.filter(Boolean);\n}\n\nconst DedupesTagsPlugin = (options) => {\n  options = options || {};\n  const dedupeKeys = options.dedupeKeys || [\"hid\", \"vmid\", \"key\"];\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        dedupeKeys.forEach((key) => {\n          if (tag.props[key]) {\n            tag.key = tag.props[key];\n            delete tag.props[key];\n          }\n        });\n        const dedupe = tag.key ? `${tag.tag}:${tag.key}` : tagDedupeKey(tag);\n        if (dedupe)\n          tag._d = dedupe;\n      },\n      \"tags:resolve\": function(ctx) {\n        const deduping = {};\n        ctx.tags.forEach((tag) => {\n          let dedupeKey = tag._d || tag._p;\n          const dupedTag = deduping[dedupeKey];\n          if (dupedTag) {\n            let strategy = tag?.tagDuplicateStrategy;\n            if (!strategy && (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\"))\n              strategy = \"merge\";\n            if (strategy === \"merge\") {\n              const oldProps = dupedTag.props;\n              [\"class\", \"style\"].forEach((key) => {\n                if (tag.props[key] && oldProps[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                }\n              });\n              deduping[dedupeKey].props = {\n                ...oldProps,\n                ...tag.props\n              };\n              return;\n            } else if (tag._e === dupedTag._e) {\n              dedupeKey = tag._d = `${dedupeKey}:${tag._p}`;\n            }\n            const propCount = Object.keys(tag.props).length;\n            if ((propCount === 0 || propCount === 1 && typeof tag.props[\"data-h-key\"] !== \"undefined\") && !tag.children) {\n              delete deduping[dedupeKey];\n              return;\n            }\n          }\n          deduping[dedupeKey] = tag;\n        });\n        ctx.tags = Object.values(deduping);\n      }\n    }\n  });\n};\n\nconst SortTagsPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const tagIndexForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n        for (const tag of ctx.tags) {\n          if (!tag.tagPriority || typeof tag.tagPriority === \"number\")\n            continue;\n          const modifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n          for (const { prefix, offset } of modifiers) {\n            if (tag.tagPriority.startsWith(prefix)) {\n              const key = tag.tagPriority.replace(prefix, \"\");\n              const index = tagIndexForKey(key);\n              if (typeof index !== \"undefined\")\n                tag._p = index + offset;\n            }\n          }\n        }\n        ctx.tags.sort((a, b) => a._p - b._p).sort(sortTags);\n      }\n    }\n  });\n};\n\nconst TitleTemplatePlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        ctx.tags = resolveTitleTemplateFromTags(ctx.tags);\n      }\n    }\n  });\n};\n\nconst DeprecatedTagAttrPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        if (typeof tag.props.body !== \"undefined\") {\n          tag.tagPosition = \"bodyClose\";\n          delete tag.props.body;\n        }\n      }\n    }\n  });\n};\n\nconst IsBrowser$1 = typeof window !== \"undefined\";\n\nconst ProvideTagHashPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": (ctx) => {\n        const { tag, entry } = ctx;\n        const isDynamic = typeof tag.props._dynamic !== \"undefined\";\n        if (!HasElementTags.includes(tag.tag) || !tag.key)\n          return;\n        tag._hash = hashCode(JSON.stringify({ tag: tag.tag, key: tag.key }));\n        if (IsBrowser$1 || getActiveHead()?.resolvedOptions?.document)\n          return;\n        if (entry._m === \"server\" || isDynamic) {\n          tag.props[`data-h-${tag._hash}`] = \"\";\n        }\n      },\n      \"tags:resolve\": (ctx) => {\n        ctx.tags = ctx.tags.map((t) => {\n          delete t.props._dynamic;\n          return t;\n        });\n      }\n    }\n  });\n};\n\nconst PatchDomOnEntryUpdatesPlugin = (options) => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function(head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\")\n          return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\")\n          delayFn = requestAnimationFrame;\n        Promise.resolve().then(function () { return index; }).then(({ debouncedRenderDOMHead }) => {\n          debouncedRenderDOMHead(head, { document: options?.document || window.document, delayFn });\n        });\n      }\n    }\n  });\n};\n\nconst EventHandlersPlugin = () => {\n  const stripEventHandlers = (mode, tag) => {\n    const props = {};\n    const eventHandlers = {};\n    Object.entries(tag.props).forEach(([key, value]) => {\n      if (key.startsWith(\"on\") && typeof value === \"function\")\n        eventHandlers[key] = value;\n      else\n        props[key] = value;\n    });\n    let delayedSrc;\n    if (mode === \"dom\" && tag.tag === \"script\" && typeof props.src === \"string\" && typeof eventHandlers.onload !== \"undefined\") {\n      delayedSrc = props.src;\n      delete props.src;\n    }\n    return { props, eventHandlers, delayedSrc };\n  };\n  return defineHeadPlugin({\n    hooks: {\n      \"ssr:render\": function(ctx) {\n        ctx.tags = ctx.tags.map((tag) => {\n          tag.props = stripEventHandlers(\"ssr\", tag).props;\n          return tag;\n        });\n      },\n      \"dom:beforeRenderTag\": function(ctx) {\n        const { props, eventHandlers, delayedSrc } = stripEventHandlers(\"dom\", ctx.tag);\n        if (!Object.keys(eventHandlers).length)\n          return;\n        ctx.tag.props = props;\n        ctx.tag._eventHandlers = eventHandlers;\n        ctx.tag._delayedSrc = delayedSrc;\n      },\n      \"dom:renderTag\": function(ctx) {\n        const $el = ctx.$el;\n        if (!ctx.tag._eventHandlers || !$el)\n          return;\n        const $eventListenerTarget = ctx.tag.tag === \"bodyAttrs\" && typeof window !== \"undefined\" ? window : $el;\n        Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {\n          const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;\n          const eventName = k.slice(2).toLowerCase();\n          const eventDedupeKey = `data-h-${eventName}`;\n          delete ctx.staleSideEffects[sdeKey];\n          if ($el.hasAttribute(eventDedupeKey))\n            return;\n          const handler = value;\n          $el.setAttribute(eventDedupeKey, \"\");\n          $eventListenerTarget.addEventListener(eventName, handler);\n          if (ctx.entry) {\n            ctx.entry._sde[sdeKey] = () => {\n              $eventListenerTarget.removeEventListener(eventName, handler);\n              $el.removeAttribute(eventDedupeKey);\n            };\n          }\n        });\n        if (ctx.tag._delayedSrc) {\n          $el.setAttribute(\"src\", ctx.tag._delayedSrc);\n        }\n      }\n    }\n  });\n};\n\nfunction asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\n\nlet activeHead;\nconst setActiveHead = (head) => activeHead = head;\nconst getActiveHead = () => activeHead;\n\nconst TagEntityBits = 10;\n\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput || e.input).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().map((t, i) => {\n    t._e = e._i;\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst CorePlugins = () => [\n  DedupesTagsPlugin(),\n  SortTagsPlugin(),\n  TitleTemplatePlugin(),\n  ProvideTagHashPlugin(),\n  EventHandlersPlugin(),\n  DeprecatedTagAttrPlugin()\n];\nconst DOMPlugins = (options = {}) => [\n  PatchDomOnEntryUpdatesPlugin({ document: options?.document, delayFn: options?.domDelayFn })\n];\nfunction createHead$1(options = {}) {\n  const head = createHeadCore({\n    ...options,\n    plugins: [...DOMPlugins(options), ...options?.plugins || []]\n  });\n  setActiveHead(head);\n  return head;\n}\nfunction createHeadCore(options = {}) {\n  let entries = [];\n  let _sde = {};\n  let _eid = 0;\n  const hooks = createHooks();\n  if (options?.hooks)\n    hooks.addHooks(options.hooks);\n  options.plugins = [\n    ...CorePlugins(),\n    ...options?.plugins || []\n  ];\n  options.plugins.forEach((p) => p.hooks && hooks.addHooks(p.hooks));\n  const updated = () => hooks.callHook(\"entries:updated\", head);\n  const head = {\n    resolvedOptions: options,\n    headEntries() {\n      return entries;\n    },\n    get hooks() {\n      return hooks;\n    },\n    push(input, options2) {\n      const activeEntry = {\n        _i: _eid++,\n        input,\n        _sde: {}\n      };\n      if (options2?.mode)\n        activeEntry._m = options2?.mode;\n      entries.push(activeEntry);\n      updated();\n      return {\n        dispose() {\n          entries = entries.filter((e) => {\n            if (e._i !== activeEntry._i)\n              return true;\n            _sde = { ..._sde, ...e._sde || {} };\n            e._sde = {};\n            updated();\n            return false;\n          });\n        },\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === activeEntry._i) {\n              activeEntry.input = e.input = input2;\n              updated();\n            }\n            return e;\n          });\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        for (const tag of await normaliseEntryTags(entry)) {\n          const tagCtx = { tag, entry };\n          await hooks.callHook(\"tag:normalise\", tagCtx);\n          resolveCtx.tags.push(tagCtx.tag);\n        }\n      }\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      return resolveCtx.tags;\n    },\n    _elMap: {},\n    _popSideEffectQueue() {\n      const sde = { ..._sde };\n      _sde = {};\n      return sde;\n    }\n  };\n  head.hooks.callHook(\"init\", head);\n  return head;\n}\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\nconst composableNames = [\n  \"useHead\",\n  \"useTagTitle\",\n  \"useTagBase\",\n  \"useTagMeta\",\n  \"useTagMetaFlat\",\n  \"useSeoMeta\",\n  \"useTagLink\",\n  \"useTagScript\",\n  \"useTagStyle\",\n  \"useTagNoscript\",\n  \"useHtmlAttrs\",\n  \"useBodyAttrs\",\n  \"useTitleTemplate\",\n  \"useServerHead\",\n  \"useServerTagTitle\",\n  \"useServerTagBase\",\n  \"useServerTagMeta\",\n  \"useServerTagMetaFlat\",\n  \"useServerTagLink\",\n  \"useServerTagScript\",\n  \"useServerTagStyle\",\n  \"useServerTagNoscript\",\n  \"useServerHtmlAttrs\",\n  \"useServerBodyAttrs\",\n  \"useServerTitleTemplate\"\n];\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    let dynamic = false;\n    const unrefdObj = Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        if (typeof v === \"function\" || isRef(v))\n          dynamic = true;\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n    if (dynamic && HasElementTags.includes(String(lastKey)))\n      unrefdObj._dynamic = true;\n    return unrefdObj;\n  }\n  return root;\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst Vue3 = version.startsWith(\"3\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst headSymbol = \"usehead\";\nfunction injectHead() {\n  return getCurrentInstance() && inject(headSymbol) || getActiveHead();\n}\nfunction createHead(options = {}) {\n  const head = createHead$1({\n    ...options,\n    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),\n    plugins: [\n      VueReactiveUseHeadPlugin(),\n      ...options?.plugins || []\n    ]\n  });\n  const vuePlugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  head.install = vuePlugin.install;\n  return head;\n}\n\nconst VueHeadMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance)\n      return;\n    const options = instance.type;\n    if (!options || !(\"head\" in options))\n      return;\n    const source = typeof options.head === \"function\" ? () => options.head() : options.head;\n    useHead(source);\n  }\n};\n\nconst VueReactiveUseHeadPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:resolve\": function(ctx) {\n        for (const entry of ctx.entries)\n          entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n      }\n    }\n  });\n};\n\nconst Vue2ProvideUnheadPlugin = function(_Vue, head) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      const origProvide = options.provide;\n      options.provide = function() {\n        let origProvideResult;\n        if (typeof origProvide === \"function\")\n          origProvideResult = origProvide.call(this);\n        else\n          origProvideResult = origProvide || {};\n        return {\n          ...origProvideResult,\n          [headSymbol]: head\n        };\n      };\n    }\n  });\n};\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst MetaPackingSchema = {\n  robots: {\n    unpack: {\n      keyValueSeparator: \":\"\n    }\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      keyValueSeparator: \" \",\n      entrySeparator: \"; \"\n    },\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: {\n    keyValue: \"fb:app_id\",\n    metaKey: \"property\"\n  },\n  msapplicationTileImage: {\n    keyValue: \"msapplication-TileImage\"\n  },\n  msapplicationTileColor: {\n    keyValue: \"msapplication-TileColor\"\n  },\n  msapplicationConfig: {\n    keyValue: \"msapplication-Config\"\n  },\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  },\n  refresh: {\n    metaKey: \"http-equiv\"\n  }\n};\nfunction resolveMetaKeyType(key) {\n  return PropertyPrefixKeys.test(key) ? \"property\" : MetaPackingSchema[key]?.metaKey || \"name\";\n}\n\nfunction unpackMeta(input) {\n  return unpackToArray(input, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n    },\n    resolveValueData({ value, key }) {\n      if (typeof value === \"object\") {\n        const definition = MetaPackingSchema[key];\n        if (key === \"refresh\")\n          return `${value.seconds};url=${value.url}`;\n        return unpackToString(\n          changeKeyCasingDeep(value),\n          {\n            entrySeparator: \", \",\n            keyValueSeparator: \"=\",\n            resolve({ value: value2, key: key2 }) {\n              if (typeof value2 === \"boolean\")\n                return `${key2}`;\n            },\n            ...definition?.unpack\n          }\n        );\n      }\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n}\n\nconst PropertyPrefixKeys = /^(og|twitter|fb)/;\nfunction fixKeyCase(key) {\n  key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  if (PropertyPrefixKeys.test(key)) {\n    key = key.replace(\"secure-url\", \"secure_url\").replace(/-/g, \":\");\n  }\n  return key;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\n\nfunction clientUseHead(input, options = {}) {\n  const head = injectHead();\n  const vm = getCurrentInstance();\n  if (!vm)\n    return head.push(input, options);\n  const resolvedInput = ref({});\n  watchEffect(() => {\n    resolvedInput.value = resolveUnrefHeadInput(input);\n  });\n  const entry = head.push(resolvedInput.value, options);\n  watch(resolvedInput, (e) => entry.patch(e));\n  onBeforeUnmount(() => {\n    entry.dispose();\n  });\n  return entry;\n}\n\nfunction serverUseHead(input, options = {}) {\n  const head = injectHead();\n  return head.push(input, options);\n}\n\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\nconst useServerTagTitle = (title) => useServerHead({ title });\nconst useServerTitleTemplate = (titleTemplate) => useServerHead({ titleTemplate });\nconst useServerTagMeta = (meta) => useServerHead({ meta: asArray(meta) });\nconst useServerTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useServerHead({ meta: input });\n};\nconst useServerTagLink = (link) => useServerHead({ link: asArray(link) });\nconst useServerTagScript = (script) => useServerHead({ script: asArray(script) });\nconst useServerTagStyle = (style) => useServerHead({ style: asArray(style) });\nconst useServerTagNoscript = (noscript) => useServerHead({ noscript: asArray(noscript) });\nconst useServerTagBase = (base) => useServerHead({ base });\nconst useServerHtmlAttrs = (attrs) => useServerHead({ htmlAttrs: attrs });\nconst useServerBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nfunction useHead(input, options = {}) {\n  const head = injectHead();\n  const isBrowser = IsBrowser || !!head.resolvedOptions?.document;\n  if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n    return;\n  return isBrowser ? clientUseHead(input, options) : serverUseHead(input, options);\n}\nconst useTagTitle = (title) => useHead({ title });\nconst useTitleTemplate = (titleTemplate) => useHead({ titleTemplate });\nconst useTagMeta = (meta) => useHead({ meta: asArray(meta) });\nconst useTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useHead({ meta: input });\n};\nconst useSeoMeta = useTagMetaFlat;\nconst useTagLink = (link) => useHead({ link: asArray(link) });\nconst useTagScript = (script) => useHead({ script: asArray(script) });\nconst useTagStyle = (style) => useHead({ style: asArray(style) });\nconst useTagNoscript = (noscript) => useHead({ noscript: asArray(noscript) });\nconst useTagBase = (base) => useHead({ base });\nconst useHtmlAttrs = (attrs) => useHead({ htmlAttrs: attrs });\nconst useBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nconst coreComposableNames = [\n  \"injectHead\"\n];\nconst unheadVueComposablesImports = [\n  {\n    from: \"@unhead/vue\",\n    imports: [...coreComposableNames, ...composableNames]\n  }\n];\n\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, VueReactiveUseHeadPlugin, asArray, createHead, createHeadCore, headSymbol, injectHead, resolveUnrefHeadInput, unheadVueComposablesImports, useBodyAttrs, useHead, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate };\n","const TagsWithInnerContent = [\"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\n\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst setAttrs = (ctx, markSideEffect) => {\n  const { tag, $el } = ctx;\n  if (!$el)\n    return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value)\n        return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect)\n          markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c))\n          $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\"))\n      markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if ($el.getAttribute(k) !== value)\n      $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag) && $el.innerHTML !== (tag.children || \"\"))\n    $el.innerHTML = tag.children || \"\";\n};\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\n\nasync function renderDOMHead(head, options = {}) {\n  const ctx = { shouldRender: true };\n  await head.hooks.callHook(\"dom:beforeRender\", ctx);\n  if (!ctx.shouldRender)\n    return;\n  const dom = options.document || window.document;\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map((entry) => entry._sde).forEach((sde) => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const preRenderTag = async (tag) => {\n    const entry = head.headEntries().find((e) => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashCode(JSON.stringify({ ...tag, _e: void 0, _p: void 0 })),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      staleSideEffects\n    };\n    await head.hooks.callHook(\"dom:beforeRenderTag\", renderCtx);\n    return renderCtx;\n  };\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markSideEffect = (ctx2, key, fn) => {\n    key = `${ctx2.renderId}:${key}`;\n    if (ctx2.entry)\n      ctx2.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  const markEl = (ctx2) => {\n    head._elMap[ctx2.renderId] = ctx2.$el;\n    renders.push(ctx2);\n    markSideEffect(ctx2, \"el\", () => {\n      ctx2.$el?.remove();\n      delete head._elMap[ctx2.renderId];\n    });\n  };\n  for (const t of await head.resolveTags()) {\n    const ctx2 = await preRenderTag(t);\n    if (!ctx2.shouldRender)\n      continue;\n    const { tag } = ctx2;\n    if (tag.tag === \"title\") {\n      dom.title = tag.children || \"\";\n      renders.push(ctx2);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx2.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx2, markSideEffect);\n      renders.push(ctx2);\n      continue;\n    }\n    ctx2.$el = head._elMap[ctx2.renderId];\n    if (!ctx2.$el && tag._hash) {\n      ctx2.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._hash}]`);\n    }\n    if (ctx2.$el) {\n      if (ctx2.tag._d)\n        setAttrs(ctx2);\n      markEl(ctx2);\n      continue;\n    }\n    ctx2.$el = dom.createElement(tag.tag);\n    setAttrs(ctx2);\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx2);\n  }\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length)\n      return;\n    for (const $el of [...dom[pos].children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags.includes(elTag))\n        continue;\n      const dedupeKey = tagDedupeKey({\n        tag: elTag,\n        props: $el.getAttributeNames().reduce((props, name) => ({ ...props, [name]: $el.getAttribute(name) }), {})\n      });\n      const matchIdx = queue.findIndex((ctx2) => ctx2 && (ctx2.tag._d === dedupeKey || $el.isEqualNode(ctx2.$el)));\n      if (matchIdx !== -1) {\n        const ctx2 = queue[matchIdx];\n        ctx2.$el = $el;\n        setAttrs(ctx2);\n        markEl(ctx2);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach((ctx2) => {\n      if (!ctx2.$el)\n        return;\n      switch (ctx2.tag.tagPosition) {\n        case \"bodyClose\":\n          dom.body.appendChild(ctx2.$el);\n          break;\n        case \"bodyOpen\":\n          dom.body.insertBefore(ctx2.$el, dom.body.firstChild);\n          break;\n        case \"head\":\n        default:\n          dom.head.appendChild(ctx2.$el);\n          break;\n      }\n      markEl(ctx2);\n    });\n  });\n  for (const ctx2 of renders)\n    await head.hooks.callHook(\"dom:renderTag\", ctx2);\n  Object.values(staleSideEffects).forEach((fn) => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || ((fn) => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise((resolve) => delayFn(() => resolve(doDomUpdate())));\n}\n\nexport { debouncedRenderDOMHead, domUpdatePromise, hashCode, renderDOMHead };\n","import { createHead as createHead$1, useHead, Vue2ProvideUnheadPlugin, injectHead } from '@unhead/vue';\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, createHeadCore, injectHead, unheadVueComposablesImports, useBodyAttrs, useHead, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate } from '@unhead/vue';\nimport { renderDOMHead, debouncedRenderDOMHead } from '@unhead/dom';\nimport { renderSSRHead } from '@unhead/ssr';\nimport { version, defineComponent, ref, onBeforeUnmount, watchEffect } from 'vue';\n\nfunction createHead(initHeadObject) {\n  const unhead = createHead$1();\n  const legacyHead = {\n    unhead,\n    install(app) {\n      if (app.config.globalProperties)\n        app.config.globalProperties.$head = unhead;\n      app.provide(\"usehead\", unhead);\n    },\n    resolveTags() {\n      return unhead.resolveTags();\n    },\n    headEntries() {\n      return unhead.headEntries();\n    },\n    headTags() {\n      return unhead.resolveTags();\n    },\n    push(input, options) {\n      return unhead.push(input, options);\n    },\n    addEntry(input, options) {\n      return unhead.push(input, options);\n    },\n    addHeadObjs(input, options) {\n      return unhead.push(input, options);\n    },\n    addReactiveEntry(input, options) {\n      const api = useHead(input, options);\n      if (typeof api !== \"undefined\")\n        return api.dispose;\n      return () => {\n      };\n    },\n    removeHeadObjs() {\n    },\n    updateDOM(document, force) {\n      if (force)\n        renderDOMHead(unhead, { document });\n      else\n        debouncedRenderDOMHead(unhead, { delayFn: (fn) => setTimeout(() => fn(), 50), document });\n    },\n    internalHooks: unhead.hooks,\n    hooks: {\n      \"before:dom\": [],\n      \"resolved:tags\": [],\n      \"resolved:entries\": []\n    }\n  };\n  unhead.addHeadObjs = legacyHead.addHeadObjs;\n  unhead.updateDOM = legacyHead.updateDOM;\n  unhead.hooks.hook(\"dom:beforeRender\", (ctx) => {\n    for (const hook of legacyHead.hooks[\"before:dom\"]) {\n      if (hook() === false)\n        ctx.shouldRender = false;\n    }\n  });\n  if (initHeadObject)\n    legacyHead.addHeadObjs(initHeadObject);\n  return legacyHead;\n}\n\nconst HeadVuePlugin = Vue2ProvideUnheadPlugin;\nconst renderHeadToString = (head) => renderSSRHead(head.unhead);\n\nconst Vue2 = version.startsWith(\"2.\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst addVNodeToHeadObj = (node, obj) => {\n  const nodeType = Vue2 ? node.tag : node.type;\n  const type = nodeType === \"html\" ? \"htmlAttrs\" : nodeType === \"body\" ? \"bodyAttrs\" : nodeType;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const nodeData = Vue2 ? node.data : node;\n  const props = (Vue2 ? nodeData.attrs : node.props) || {};\n  if (Vue2) {\n    if (nodeData.staticClass)\n      props.class = nodeData.staticClass;\n    if (nodeData.staticStyle)\n      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(\";\");\n  }\n  if (node.children) {\n    const childrenAttr = Vue2 ? \"text\" : \"children\";\n    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];\n  }\n  if (Array.isArray(obj[type]))\n    obj[type].push(props);\n  else if (type === \"title\")\n    obj.title = props.children;\n  else\n    obj[type] = props;\n};\nconst vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children)\n        addVNodeToHeadObj(childNode, obj);\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nconst Head = /* @__PURE__ */ defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    const obj = ref({});\n    const entry = head.push(obj);\n    if (IsBrowser) {\n      onBeforeUnmount(() => {\n        entry.dispose();\n      });\n    }\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        entry.patch(vnodesToHeadObj(slots.default()));\n      });\n      return null;\n    };\n  }\n});\n\nexport { Head, HeadVuePlugin, createHead, renderHeadToString };\n","export const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appHead = {\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"}],\"link\":[],\"style\":[],\"script\":[],\"noscript\":[]}\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"","import { createHead, useHead } from \"@vueuse/head\";\nimport { defineNuxtPlugin } from \"#app\";\nimport { appHead } from \"#build/nuxt.config.mjs\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const head = createHead();\n  head.push(appHead);\n  nuxtApp.vueApp.use(head);\n  if (process.client) {\n    let pauseDOMUpdates = true;\n    const unpauseDom = () => {\n      pauseDOMUpdates = false;\n      head.internalHooks.callHook(\"entries:updated\", head.unhead);\n    };\n    head.internalHooks.hook(\"dom:beforeRender\", (context) => {\n      context.shouldRender = !pauseDOMUpdates;\n    });\n    nuxtApp.hooks.hook(\"page:start\", () => {\n      pauseDOMUpdates = true;\n    });\n    nuxtApp.hooks.hook(\"page:finish\", unpauseDom);\n    nuxtApp.hooks.hook(\"app:mounted\", unpauseDom);\n  }\n  nuxtApp._useHead = useHead;\n  if (process.server) {\n    nuxtApp.ssrContext.renderMeta = async () => {\n      const { renderSSRHead } = await import(\"@unhead/ssr\");\n      const meta = await renderSSRHead(head.unhead);\n      return {\n        ...meta,\n        bodyScriptsPrepend: meta.bodyTagsOpen,\n        bodyScripts: meta.bodyTags\n      };\n    };\n  }\n});\n","import { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/Bookmarks.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/EdProf.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/your_company.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/Add.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/[id_article]/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/edit.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/new_user.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/edit.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/edit.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/add.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/add.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/add.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/general/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/tags/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/error.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/index.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/login.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/register.vue?macro=true\";\nimport { default as C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta } from \"C:/NUXT/itlWiki_3/ITLWIKI/pages/test_form.vue?macro=true\";\nexport default [\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta?.name ?? \"Account-Bookmarks\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta?.path ?? \"/Account/Bookmarks\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/Bookmarks.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47Bookmarks_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/Bookmarks.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta?.name ?? \"Account-EdProf\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta?.path ?? \"/Account/EdProf\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/EdProf.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47EdProf_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/EdProf.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta?.name ?? \"Account-your_company\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta?.path ?? \"/Account/your_company\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/your_company.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Account_47your_company_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/Account/your_company.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta?.name ?? \"Team-Add\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta?.path ?? \"/Team/Add\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/Add.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47Add_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/Add.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta?.name ?? \"Team\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta?.path ?? \"/Team\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47Team_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/Team/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta?.name ?? \"name.itl.wiki\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta?.path ?? \"/:name.itl.wiki\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta?.name ?? \"name.itl.wiki-moderation-id_article\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta?.path ?? \"/:name.itl.wiki/moderation/:id_article\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/[id_article]/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47_91id_article_93_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/[id_article]/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta?.name ?? \"name.itl.wiki-moderation\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta?.path ?? \"/:name.itl.wiki/moderation\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47moderation_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/moderation/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta?.name ?? \"name.itl.wiki-my_works-id_article-edit\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta?.path ?? \"/:name.itl.wiki/my_works/:id_article/edit\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/edit.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47edit_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/edit.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta?.name ?? \"name.itl.wiki-my_works-id_article\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta?.path ?? \"/:name.itl.wiki/my_works/:id_article\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47_91id_article_93_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/[id_article]/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta?.name ?? \"name.itl.wiki-my_works\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta?.path ?? \"/:name.itl.wiki/my_works\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47my_works_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/my_works/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta?.name ?? \"name.itl.wiki-new_user\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta?.path ?? \"/:name.itl.wiki/new_user\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/new_user.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47new_user_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/new_user.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta?.name ?? \"name.itl.wiki-section-id_section-edit\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta?.path ?? \"/:name.itl.wiki/section/:id_section/edit\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/edit.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47edit_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/edit.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta?.name ?? \"name.itl.wiki-section-id_section\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta?.path ?? \"/:name.itl.wiki/section/:id_section\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta?.name ?? \"name.itl.wiki-section-id_section-items-id_items-edit\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta?.path ?? \"/:name.itl.wiki/section/:id_section/items/:id_items/edit\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/edit.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47edit_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/edit.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta?.name ?? \"name.itl.wiki-section-id_section-items-id_items\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta?.path ?? \"/:name.itl.wiki/section/:id_section/items/:id_items\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47_91id_items_93_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/[id_items]/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta?.name ?? \"name.itl.wiki-section-id_section-items-add\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta?.path ?? \"/:name.itl.wiki/section/:id_section/items/add\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/add.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47_91id_section_93_47items_47add_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/[id_section]/items/add.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta?.name ?? \"name.itl.wiki-section-add\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta?.path ?? \"/:name.itl.wiki/section/add\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/add.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47section_47add_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/section/add.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta?.name ?? \"name.itl.wiki-setting-emplayees-add\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta?.path ?? \"/:name.itl.wiki/setting/emplayees/add\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/add.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47add_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/add.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta?.name ?? \"name.itl.wiki-setting-emplayees\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta?.path ?? \"/:name.itl.wiki/setting/emplayees\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47emplayees_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/emplayees/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta?.name ?? \"name.itl.wiki-setting-general\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta?.path ?? \"/:name.itl.wiki/setting/general\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/general/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47general_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/general/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta?.name ?? \"name.itl.wiki-setting-tags\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta?.path ?? \"/:name.itl.wiki/setting/tags\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/tags/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47_91name_93_46itl_46wiki_47setting_47tags_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/[name].itl.wiki/setting/tags/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta?.name ?? \"error\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta?.path ?? \"/error\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/error.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47error_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/error.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta?.name ?? \"index\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta?.path ?? \"/\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/index.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47index_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta?.name ?? \"login\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta?.path ?? \"/login\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/login.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47login_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/login.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta?.name ?? \"register\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta?.path ?? \"/register\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/register.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47register_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/register.vue\").then(m => m.default || m)\n  },\n  {\n    name: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta?.name ?? \"test_form\",\n    path: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta?.path ?? \"/test_form\",\n    file: \"C:/NUXT/itlWiki_3/ITLWIKI/pages/test_form.vue\",\n    children: [],\n    meta: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta,\n    alias: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta?.alias || [],\n    redirect: C_58_47NUXT_47itlWiki_3_47ITLWIKI_47pages_47test_form_46vueMeta?.redirect || undefined,\n    component: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/pages/test_form.vue\").then(m => m.default || m)\n  }\n]","import { nextTick } from \"vue\";\nimport { useNuxtApp } from \"#app\";\nimport { appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    let position = savedPosition || void 0;\n    if (!position && from && to && to.meta.scrollToTop !== false && _isDifferentRoute(from, to)) {\n      position = { left: 0, top: 0 };\n    }\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash) };\n      }\n    }\n    const hasTransition = (route) => !!(route.meta.pageTransition ?? defaultPageTransition);\n    const hookToWait = hasTransition(from) && hasTransition(to) ? \"page:transition:finish\" : \"page:finish\";\n    return new Promise((resolve) => {\n      nuxtApp.hooks.hookOnce(hookToWait, async () => {\n        await nextTick();\n        if (to.hash) {\n          position = { el: to.hash, top: _getHashElementScrollMarginTop(to.hash) };\n        }\n        resolve(position);\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return parseFloat(getComputedStyle(elem).scrollMarginTop);\n    }\n  } catch {\n  }\n  return 0;\n}\nfunction _isDifferentRoute(a, b) {\n  const samePageComponent = a.matched[0] === b.matched[0];\n  if (!samePageComponent) {\n    return true;\n  }\n  if (samePageComponent && JSON.stringify(a.params) !== JSON.stringify(b.params)) {\n    return true;\n  }\n  return false;\n}\n","import routerOptions0 from \"C:/NUXT/itlWiki_3/ITLWIKI/node_modules/nuxt/dist/pages/runtime/router.options\";\nconst configRouterOptions = {}\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import { createError, defineNuxtRouteMiddleware } from \"#app\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (typeof result === \"boolean\") {\n    return result;\n  }\n  return createError(result);\n});\n","import validate from \"C:/NUXT/itlWiki_3/ITLWIKI/node_modules/nuxt/dist/pages/runtime/validate.mjs\";\nexport const globalMiddleware = [\n  validate\n]\nexport const namedMiddleware = {\n  auth: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/middleware/auth.js\"),\n  team: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/middleware/team.js\")\n}","import { computed, reactive, shallowRef } from \"vue\";\nimport {\n  createRouter,\n  createWebHistory,\n  createMemoryHistory,\n  createWebHashHistory\n} from \"vue-router\";\nimport { createError } from \"h3\";\nimport { withoutBase, isEqual } from \"ufo\";\nimport { callWithNuxt, defineNuxtPlugin, useRuntimeConfig, showError, clearError, navigateTo, useError, useState } from \"#app\";\nimport _routes from \"#build/routes\";\nimport routerOptions from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const path = withoutBase(pathname, base);\n  return path + search + hash;\n}\nexport default defineNuxtPlugin(async (nuxtApp) => {\n  let routerBase = useRuntimeConfig().app.baseURL;\n  if (routerOptions.hashMode && !routerBase.includes(\"#\")) {\n    routerBase += \"#\";\n  }\n  const history = routerOptions.history?.(routerBase) ?? (process.client ? routerOptions.hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n  const routes = routerOptions.routes?.(_routes) ?? _routes;\n  const initialURL = process.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location);\n  const router = createRouter({\n    ...routerOptions,\n    history,\n    routes\n  });\n  nuxtApp.vueApp.use(router);\n  const previousRoute = shallowRef(router.currentRoute.value);\n  router.afterEach((_to, from) => {\n    previousRoute.value = from;\n  });\n  Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n    get: () => previousRoute.value\n  });\n  const _route = shallowRef(router.resolve(initialURL));\n  const syncCurrentRoute = () => {\n    _route.value = router.currentRoute.value;\n  };\n  nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n  router.afterEach((to, from) => {\n    if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n      syncCurrentRoute();\n    }\n  });\n  const route = {};\n  for (const key in _route.value) {\n    route[key] = computed(() => _route.value[key]);\n  }\n  nuxtApp._route = reactive(route);\n  nuxtApp._middleware = nuxtApp._middleware || {\n    global: [],\n    named: {}\n  };\n  const error = useError();\n  try {\n    if (process.server) {\n      await router.push(initialURL);\n    }\n    await router.isReady();\n  } catch (error2) {\n    callWithNuxt(nuxtApp, showError, [error2]);\n  }\n  const initialLayout = useState(\"_layout\");\n  router.beforeEach(async (to, from) => {\n    to.meta = reactive(to.meta);\n    if (nuxtApp.isHydrating) {\n      to.meta.layout = initialLayout.value ?? to.meta.layout;\n    }\n    nuxtApp._processingMiddleware = true;\n    const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n    for (const component of to.matched) {\n      const componentMiddleware = component.meta.middleware;\n      if (!componentMiddleware) {\n        continue;\n      }\n      if (Array.isArray(componentMiddleware)) {\n        for (const entry of componentMiddleware) {\n          middlewareEntries.add(entry);\n        }\n      } else {\n        middlewareEntries.add(componentMiddleware);\n      }\n    }\n    for (const entry of middlewareEntries) {\n      const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n      if (!middleware) {\n        if (process.dev) {\n          throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n        }\n        throw new Error(`Unknown route middleware: '${entry}'.`);\n      }\n      const result = await callWithNuxt(nuxtApp, middleware, [to, from]);\n      if (process.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n        if (result === false || result instanceof Error) {\n          const error2 = result || createError({\n            statusCode: 404,\n            statusMessage: `Page Not Found: ${initialURL}`\n          });\n          await callWithNuxt(nuxtApp, showError, [error2]);\n          return false;\n        }\n      }\n      if (result || result === false) {\n        return result;\n      }\n    }\n  });\n  router.afterEach(async (to) => {\n    delete nuxtApp._processingMiddleware;\n    if (process.client && !nuxtApp.isHydrating && error.value) {\n      await callWithNuxt(nuxtApp, clearError);\n    }\n    if (to.matched.length === 0) {\n      callWithNuxt(nuxtApp, showError, [createError({\n        statusCode: 404,\n        fatal: false,\n        statusMessage: `Page not found: ${to.fullPath}`\n      })]);\n    } else if (process.server) {\n      const currentURL = to.fullPath || \"/\";\n      if (!isEqual(currentURL, initialURL)) {\n        await callWithNuxt(nuxtApp, navigateTo, [currentURL]);\n      }\n    }\n  });\n  nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n    try {\n      await router.replace({\n        ...router.resolve(initialURL),\n        name: void 0,\n        force: true\n      });\n    } catch (error2) {\n      callWithNuxt(nuxtApp, showError, [error2]);\n    }\n  });\n  return { provide: { router } };\n});\n","import node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq from \"C:/NUXT/itlWiki_3/ITLWIKI/node_modules/@pinia/nuxt/dist/runtime/plugin.vue3.mjs\";\nimport _nuxt_components_plugin_mjs_KR1HBZs4kY from \"C:/NUXT/itlWiki_3/ITLWIKI/.nuxt/components.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0 from \"C:/NUXT/itlWiki_3/ITLWIKI/node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs\";\nimport node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB from \"C:/NUXT/itlWiki_3/ITLWIKI/node_modules/nuxt/dist/pages/runtime/router.mjs\";\nexport default [\n  node_modules__64pinia_nuxt_dist_runtime_plugin_vue3_mjs_A0OWXRrUgq,\n  _nuxt_components_plugin_mjs_KR1HBZs4kY,\n  node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0,\n  node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB\n]","import { KeepAlive, h } from \"vue\";\nconst interpolatePath = (route, match) => {\n  return match.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (override, routeProps) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => process.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\n","import { defineComponent, h } from \"vue\";\nconst Fragment = defineComponent({\n  setup(_props, { slots }) {\n    return () => slots.default?.();\n  }\n});\nexport const _wrapIf = (component, props, slots) => {\n  return { default: () => props ? h(component, props === true ? {} : props, slots) : h(Fragment, {}, slots) };\n};\n","import { computed, defineComponent, h, provide, reactive, onMounted, nextTick, Suspense, Transition } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, wrapInKeepAlive } from \"./utils.mjs\";\nimport { useNuxtApp } from \"#app\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { appPageTransition as defaultPageTransition, appKeepalive as defaultKeepaliveConfig } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs }) {\n    const nuxtApp = useNuxtApp();\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          if (!routeProps.Component) {\n            return;\n          }\n          const key = generateRouteKey(props.pageKey, routeProps);\n          const done = nuxtApp.deferHydration();\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            { onAfterLeave: () => {\n              nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n            } }\n          ].filter(Boolean));\n          return _wrapIf(\n            Transition,\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig,\n              h(Suspense, {\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).finally(done));\n                }\n              }, { default: () => h(Component, { key, routeProps, pageKey: key, hasTransition }) })\n            )\n          ).default();\n        }\n      });\n    };\n  }\n});\nfunction _toArray(val) {\n  return Array.isArray(val) ? val : val ? [val] : [];\n}\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.map((prop) => ({\n    ...prop,\n    onAfterLeave: _toArray(prop.onAfterLeave)\n  }));\n  return defu(..._props);\n}\nconst Component = defineComponent({\n  props: [\"routeProps\", \"pageKey\", \"hasTransition\"],\n  setup(props) {\n    const previousKey = props.pageKey;\n    const previousRoute = props.routeProps.route;\n    const route = {};\n    for (const key in props.routeProps.route) {\n      route[key] = computed(() => previousKey === props.pageKey ? props.routeProps.route[key] : previousRoute[key]);\n    }\n    provide(\"_route\", reactive(route));\n    let vnode;\n    if (process.dev && process.client && props.hasTransition) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (process.dev && process.client) {\n        vnode = h(props.routeProps.Component);\n        return vnode;\n      }\n      return h(props.routeProps.Component);\n    };\n  }\n});\n","export default {\n  company: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/layouts/company.vue\").then(m => m.default || m),\n  default: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/layouts/default.vue\").then(m => m.default || m),\n  navbar: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/layouts/navbar.vue\").then(m => m.default || m),\n  user: () => import(\"C:/NUXT/itlWiki_3/ITLWIKI/layouts/user.vue\").then(m => m.default || m)\n}","import { computed, defineComponent, h, inject, nextTick, onMounted, Transition, unref } from \"vue\";\nimport { _wrapIf } from \"./utils.mjs\";\nimport { useRoute } from \"#app\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  props: {\n    name: String,\n    ...process.dev ? { hasTransition: Boolean } : {}\n  },\n  async setup(props, context) {\n    let vnode;\n    if (process.dev && process.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if (props.name && [\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            console.warn(`[nuxt] \\`${props.name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    const LayoutComponent = await layouts[props.name]().then((r) => r.default || r);\n    return () => {\n      if (process.dev && process.client && props.hasTransition) {\n        vnode = h(LayoutComponent, {}, context.slots);\n        return vnode;\n      }\n      return h(LayoutComponent, {}, context.slots);\n    };\n  }\n});\nexport default defineComponent({\n  props: {\n    name: {\n      type: [String, Boolean, Object],\n      default: null\n    }\n  },\n  setup(props, context) {\n    const injectedRoute = inject(\"_route\");\n    const route = injectedRoute === useRoute() ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => unref(props.name) ?? route.meta.layout ?? \"default\");\n    let vnode;\n    let _layout;\n    if (process.dev && process.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if (_layout && _layout in layouts && [\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            console.warn(`[nuxt] \\`${_layout}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      if (process.dev && layout.value && !hasLayout && layout.value !== \"default\") {\n        console.warn(`Invalid layout \\`${layout.value}\\` selected.`);\n      }\n      const transitionProps = route.meta.layoutTransition ?? defaultLayoutTransition;\n      return _wrapIf(Transition, hasLayout && transitionProps, {\n        default: () => _wrapIf(LayoutLoader, hasLayout && { key: layout.value, name: layout.value, hasTransition: process.dev ? !!transitionProps : void 0 }, context.slots).default()\n      }).default();\n    };\n  }\n});\n","import { createSSRApp, createApp, nextTick } from \"vue\";\nimport { $fetch } from \"ofetch\";\nimport { baseURL } from \"#build/paths.mjs\";\nimport { createNuxtApp, applyPlugins, normalizePlugins } from \"#app\";\nimport \"#build/css\";\nimport _plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { appRootId } from \"#build/nuxt.config.mjs\";\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  });\n}\nlet entry;\nconst plugins = normalizePlugins(_plugins);\nif (process.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    return vueApp;\n  };\n}\nif (process.client) {\n  if (process.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  entry = async function initApp() {\n    const isSSR = Boolean(window.__NUXT__?.serverRendered);\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(\"#\" + appRootId);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n  };\n  entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n  });\n}\nexport default (ctx) => entry(ctx);\n"],"file":"server.mjs"}